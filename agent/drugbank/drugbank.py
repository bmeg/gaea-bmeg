#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Apr  3 01:14:49 2016 by generateDS.py version 2.21a.
#
# Command line options:
#   ('-o', 'drugbank.py')
#
# Command line arguments:
#   drugbank.xsd
#
# Command line:
#   ./venv/bin/generateDS.py -o "drugbank.py" drugbank.xsd
#
# Current working directory (os.getcwd()):
#   importers
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class drugbank_type(GeneratedsSuper):
    """This is the root element type for the DrugBank database schema.The
    DrugBank version for the exported XML file.The date the XML file
    was exported."""
    subclass = None
    superclass = None
    def __init__(self, version=None, exported_on=None, drug=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        if isinstance(exported_on, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exported_on, '%Y-%m-%d').date()
        else:
            initvalue_ = exported_on
        self.exported_on = initvalue_
        if drug is None:
            self.drug = []
        else:
            self.drug = drug
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugbank_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugbank_type.subclass:
            return drugbank_type.subclass(*args_, **kwargs_)
        else:
            return drugbank_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drug(self): return self.drug
    def set_drug(self, drug): self.drug = drug
    def add_drug(self, value): self.drug.append(value)
    def insert_drug_at(self, index, value): self.drug.insert(index, value)
    def replace_drug_at(self, index, value): self.drug[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_exported_on(self): return self.exported_on
    def set_exported_on(self, exported_on): self.exported_on = exported_on
    def hasContent_(self):
        if (
            self.drug
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drugbank-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drugbank-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drugbank-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drugbank-type'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.exported_on is not None and 'exported_on' not in already_processed:
            already_processed.add('exported_on')
            outfile.write(' exported-on="%s"' % self.gds_format_date(self.exported_on, input_name='exported-on'))
    def exportChildren(self, outfile, level, namespace_='', name_='drugbank-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for drug_ in self.drug:
            drug_.export(outfile, level, namespace_, name_='drug', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('exported-on', node)
        if value is not None and 'exported-on' not in already_processed:
            already_processed.add('exported-on')
            try:
                self.exported_on = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (exported-on): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drug':
            obj_ = drug_type.factory()
            obj_.build(child_)
            self.drug.append(obj_)
            obj_.original_tagname_ = 'drug'
# end class drugbank_type


class drug_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, created=None, updated=None, drugbank_id=None, name=None, description=None, cas_number=None, groups=None, general_references=None, synthesis_reference=None, indication=None, pharmacodynamics=None, mechanism_of_action=None, toxicity=None, metabolism=None, absorption=None, half_life=None, protein_binding=None, route_of_elimination=None, volume_of_distribution=None, clearance=None, classification=None, salts=None, synonyms=None, products=None, international_brands=None, mixtures=None, packagers=None, manufacturers=None, prices=None, categories=None, affected_organisms=None, dosages=None, atc_codes=None, ahfs_codes=None, patents=None, food_interactions=None, drug_interactions=None, sequences=None, calculated_properties=None, experimental_properties=None, external_identifiers=None, external_links=None, pathways=None, reactions=None, snp_effects=None, snp_adverse_drug_reactions=None, targets=None, enzymes=None, carriers=None, transporters=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        if isinstance(created, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(created, '%Y-%m-%d').date()
        else:
            initvalue_ = created
        self.created = initvalue_
        if isinstance(updated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updated, '%Y-%m-%d').date()
        else:
            initvalue_ = updated
        self.updated = initvalue_
        if drugbank_id is None:
            self.drugbank_id = []
        else:
            self.drugbank_id = drugbank_id
        self.name = name
        self.description = description
        self.cas_number = cas_number
        self.groups = groups
        self.general_references = general_references
        self.synthesis_reference = synthesis_reference
        self.indication = indication
        self.pharmacodynamics = pharmacodynamics
        self.mechanism_of_action = mechanism_of_action
        self.toxicity = toxicity
        self.metabolism = metabolism
        self.absorption = absorption
        self.half_life = half_life
        self.protein_binding = protein_binding
        self.route_of_elimination = route_of_elimination
        self.volume_of_distribution = volume_of_distribution
        self.clearance = clearance
        self.classification = classification
        self.salts = salts
        self.synonyms = synonyms
        self.products = products
        self.international_brands = international_brands
        self.mixtures = mixtures
        self.packagers = packagers
        self.manufacturers = manufacturers
        self.prices = prices
        self.categories = categories
        self.affected_organisms = affected_organisms
        self.dosages = dosages
        self.atc_codes = atc_codes
        self.ahfs_codes = ahfs_codes
        self.patents = patents
        self.food_interactions = food_interactions
        self.drug_interactions = drug_interactions
        self.sequences = sequences
        self.calculated_properties = calculated_properties
        self.experimental_properties = experimental_properties
        self.external_identifiers = external_identifiers
        self.external_links = external_links
        self.pathways = pathways
        self.reactions = reactions
        self.snp_effects = snp_effects
        self.snp_adverse_drug_reactions = snp_adverse_drug_reactions
        self.targets = targets
        self.enzymes = enzymes
        self.carriers = carriers
        self.transporters = transporters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drug_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drug_type.subclass:
            return drug_type.subclass(*args_, **kwargs_)
        else:
            return drug_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drugbank_id(self): return self.drugbank_id
    def set_drugbank_id(self, drugbank_id): self.drugbank_id = drugbank_id
    def add_drugbank_id(self, value): self.drugbank_id.append(value)
    def insert_drugbank_id_at(self, index, value): self.drugbank_id.insert(index, value)
    def replace_drugbank_id_at(self, index, value): self.drugbank_id[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_cas_number(self): return self.cas_number
    def set_cas_number(self, cas_number): self.cas_number = cas_number
    def get_groups(self): return self.groups
    def set_groups(self, groups): self.groups = groups
    def get_general_references(self): return self.general_references
    def set_general_references(self, general_references): self.general_references = general_references
    def get_synthesis_reference(self): return self.synthesis_reference
    def set_synthesis_reference(self, synthesis_reference): self.synthesis_reference = synthesis_reference
    def get_indication(self): return self.indication
    def set_indication(self, indication): self.indication = indication
    def get_pharmacodynamics(self): return self.pharmacodynamics
    def set_pharmacodynamics(self, pharmacodynamics): self.pharmacodynamics = pharmacodynamics
    def get_mechanism_of_action(self): return self.mechanism_of_action
    def set_mechanism_of_action(self, mechanism_of_action): self.mechanism_of_action = mechanism_of_action
    def get_toxicity(self): return self.toxicity
    def set_toxicity(self, toxicity): self.toxicity = toxicity
    def get_metabolism(self): return self.metabolism
    def set_metabolism(self, metabolism): self.metabolism = metabolism
    def get_absorption(self): return self.absorption
    def set_absorption(self, absorption): self.absorption = absorption
    def get_half_life(self): return self.half_life
    def set_half_life(self, half_life): self.half_life = half_life
    def get_protein_binding(self): return self.protein_binding
    def set_protein_binding(self, protein_binding): self.protein_binding = protein_binding
    def get_route_of_elimination(self): return self.route_of_elimination
    def set_route_of_elimination(self, route_of_elimination): self.route_of_elimination = route_of_elimination
    def get_volume_of_distribution(self): return self.volume_of_distribution
    def set_volume_of_distribution(self, volume_of_distribution): self.volume_of_distribution = volume_of_distribution
    def get_clearance(self): return self.clearance
    def set_clearance(self, clearance): self.clearance = clearance
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_salts(self): return self.salts
    def set_salts(self, salts): self.salts = salts
    def get_synonyms(self): return self.synonyms
    def set_synonyms(self, synonyms): self.synonyms = synonyms
    def get_products(self): return self.products
    def set_products(self, products): self.products = products
    def get_international_brands(self): return self.international_brands
    def set_international_brands(self, international_brands): self.international_brands = international_brands
    def get_mixtures(self): return self.mixtures
    def set_mixtures(self, mixtures): self.mixtures = mixtures
    def get_packagers(self): return self.packagers
    def set_packagers(self, packagers): self.packagers = packagers
    def get_manufacturers(self): return self.manufacturers
    def set_manufacturers(self, manufacturers): self.manufacturers = manufacturers
    def get_prices(self): return self.prices
    def set_prices(self, prices): self.prices = prices
    def get_categories(self): return self.categories
    def set_categories(self, categories): self.categories = categories
    def get_affected_organisms(self): return self.affected_organisms
    def set_affected_organisms(self, affected_organisms): self.affected_organisms = affected_organisms
    def get_dosages(self): return self.dosages
    def set_dosages(self, dosages): self.dosages = dosages
    def get_atc_codes(self): return self.atc_codes
    def set_atc_codes(self, atc_codes): self.atc_codes = atc_codes
    def get_ahfs_codes(self): return self.ahfs_codes
    def set_ahfs_codes(self, ahfs_codes): self.ahfs_codes = ahfs_codes
    def get_patents(self): return self.patents
    def set_patents(self, patents): self.patents = patents
    def get_food_interactions(self): return self.food_interactions
    def set_food_interactions(self, food_interactions): self.food_interactions = food_interactions
    def get_drug_interactions(self): return self.drug_interactions
    def set_drug_interactions(self, drug_interactions): self.drug_interactions = drug_interactions
    def get_sequences(self): return self.sequences
    def set_sequences(self, sequences): self.sequences = sequences
    def get_calculated_properties(self): return self.calculated_properties
    def set_calculated_properties(self, calculated_properties): self.calculated_properties = calculated_properties
    def get_experimental_properties(self): return self.experimental_properties
    def set_experimental_properties(self, experimental_properties): self.experimental_properties = experimental_properties
    def get_external_identifiers(self): return self.external_identifiers
    def set_external_identifiers(self, external_identifiers): self.external_identifiers = external_identifiers
    def get_external_links(self): return self.external_links
    def set_external_links(self, external_links): self.external_links = external_links
    def get_pathways(self): return self.pathways
    def set_pathways(self, pathways): self.pathways = pathways
    def get_reactions(self): return self.reactions
    def set_reactions(self, reactions): self.reactions = reactions
    def get_snp_effects(self): return self.snp_effects
    def set_snp_effects(self, snp_effects): self.snp_effects = snp_effects
    def get_snp_adverse_drug_reactions(self): return self.snp_adverse_drug_reactions
    def set_snp_adverse_drug_reactions(self, snp_adverse_drug_reactions): self.snp_adverse_drug_reactions = snp_adverse_drug_reactions
    def get_targets(self): return self.targets
    def set_targets(self, targets): self.targets = targets
    def get_enzymes(self): return self.enzymes
    def set_enzymes(self, enzymes): self.enzymes = enzymes
    def get_carriers(self): return self.carriers
    def set_carriers(self, carriers): self.carriers = carriers
    def get_transporters(self): return self.transporters
    def set_transporters(self, transporters): self.transporters = transporters
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_updated(self): return self.updated
    def set_updated(self, updated): self.updated = updated
    def hasContent_(self):
        if (
            self.drugbank_id or
            self.name is not None or
            self.description is not None or
            self.cas_number is not None or
            self.groups is not None or
            self.general_references is not None or
            self.synthesis_reference is not None or
            self.indication is not None or
            self.pharmacodynamics is not None or
            self.mechanism_of_action is not None or
            self.toxicity is not None or
            self.metabolism is not None or
            self.absorption is not None or
            self.half_life is not None or
            self.protein_binding is not None or
            self.route_of_elimination is not None or
            self.volume_of_distribution is not None or
            self.clearance is not None or
            self.classification is not None or
            self.salts is not None or
            self.synonyms is not None or
            self.products is not None or
            self.international_brands is not None or
            self.mixtures is not None or
            self.packagers is not None or
            self.manufacturers is not None or
            self.prices is not None or
            self.categories is not None or
            self.affected_organisms is not None or
            self.dosages is not None or
            self.atc_codes is not None or
            self.ahfs_codes is not None or
            self.patents is not None or
            self.food_interactions is not None or
            self.drug_interactions is not None or
            self.sequences is not None or
            self.calculated_properties is not None or
            self.experimental_properties is not None or
            self.external_identifiers is not None or
            self.external_links is not None or
            self.pathways is not None or
            self.reactions is not None or
            self.snp_effects is not None or
            self.snp_adverse_drug_reactions is not None or
            self.targets is not None or
            self.enzymes is not None or
            self.carriers is not None or
            self.transporters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drug-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drug-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drug-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drug-type'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            outfile.write(' created="%s"' % self.gds_format_date(self.created, input_name='created'))
        if self.updated is not None and 'updated' not in already_processed:
            already_processed.add('updated')
            outfile.write(' updated="%s"' % self.gds_format_date(self.updated, input_name='updated'))
    def exportChildren(self, outfile, level, namespace_='', name_='drug-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for drugbank_id_ in self.drugbank_id:
            drugbank_id_.export(outfile, level, namespace_, name_='drugbank-id', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.cas_number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scas-number>%s</%scas-number>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cas_number), input_name='cas-number')), namespace_, eol_))
        if self.groups is not None:
            self.groups.export(outfile, level, namespace_, name_='groups', pretty_print=pretty_print)
        if self.general_references is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeneral-references>%s</%sgeneral-references>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.general_references), input_name='general-references')), namespace_, eol_))
        if self.synthesis_reference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssynthesis-reference>%s</%ssynthesis-reference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.synthesis_reference), input_name='synthesis-reference')), namespace_, eol_))
        if self.indication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindication>%s</%sindication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indication), input_name='indication')), namespace_, eol_))
        if self.pharmacodynamics is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spharmacodynamics>%s</%spharmacodynamics>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pharmacodynamics), input_name='pharmacodynamics')), namespace_, eol_))
        if self.mechanism_of_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smechanism-of-action>%s</%smechanism-of-action>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mechanism_of_action), input_name='mechanism-of-action')), namespace_, eol_))
        if self.toxicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoxicity>%s</%stoxicity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.toxicity), input_name='toxicity')), namespace_, eol_))
        if self.metabolism is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smetabolism>%s</%smetabolism>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.metabolism), input_name='metabolism')), namespace_, eol_))
        if self.absorption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sabsorption>%s</%sabsorption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.absorption), input_name='absorption')), namespace_, eol_))
        if self.half_life is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shalf-life>%s</%shalf-life>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.half_life), input_name='half-life')), namespace_, eol_))
        if self.protein_binding is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotein-binding>%s</%sprotein-binding>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.protein_binding), input_name='protein-binding')), namespace_, eol_))
        if self.route_of_elimination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute-of-elimination>%s</%sroute-of-elimination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.route_of_elimination), input_name='route-of-elimination')), namespace_, eol_))
        if self.volume_of_distribution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume-of-distribution>%s</%svolume-of-distribution>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.volume_of_distribution), input_name='volume-of-distribution')), namespace_, eol_))
        if self.clearance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclearance>%s</%sclearance>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.clearance), input_name='clearance')), namespace_, eol_))
        if self.classification is not None:
            self.classification.export(outfile, level, namespace_, name_='classification', pretty_print=pretty_print)
        if self.salts is not None:
            self.salts.export(outfile, level, namespace_, name_='salts', pretty_print=pretty_print)
        if self.synonyms is not None:
            self.synonyms.export(outfile, level, namespace_, name_='synonyms', pretty_print=pretty_print)
        if self.products is not None:
            self.products.export(outfile, level, namespace_, name_='products', pretty_print=pretty_print)
        if self.international_brands is not None:
            self.international_brands.export(outfile, level, namespace_, name_='international-brands', pretty_print=pretty_print)
        if self.mixtures is not None:
            self.mixtures.export(outfile, level, namespace_, name_='mixtures', pretty_print=pretty_print)
        if self.packagers is not None:
            self.packagers.export(outfile, level, namespace_, name_='packagers', pretty_print=pretty_print)
        if self.manufacturers is not None:
            self.manufacturers.export(outfile, level, namespace_, name_='manufacturers', pretty_print=pretty_print)
        if self.prices is not None:
            self.prices.export(outfile, level, namespace_, name_='prices', pretty_print=pretty_print)
        if self.categories is not None:
            self.categories.export(outfile, level, namespace_, name_='categories', pretty_print=pretty_print)
        if self.affected_organisms is not None:
            self.affected_organisms.export(outfile, level, namespace_, name_='affected-organisms', pretty_print=pretty_print)
        if self.dosages is not None:
            self.dosages.export(outfile, level, namespace_, name_='dosages', pretty_print=pretty_print)
        if self.atc_codes is not None:
            self.atc_codes.export(outfile, level, namespace_, name_='atc-codes', pretty_print=pretty_print)
        if self.ahfs_codes is not None:
            self.ahfs_codes.export(outfile, level, namespace_, name_='ahfs-codes', pretty_print=pretty_print)
        if self.patents is not None:
            self.patents.export(outfile, level, namespace_, name_='patents', pretty_print=pretty_print)
        if self.food_interactions is not None:
            self.food_interactions.export(outfile, level, namespace_, name_='food-interactions', pretty_print=pretty_print)
        if self.drug_interactions is not None:
            self.drug_interactions.export(outfile, level, namespace_, name_='drug-interactions', pretty_print=pretty_print)
        if self.sequences is not None:
            self.sequences.export(outfile, level, namespace_, name_='sequences', pretty_print=pretty_print)
        if self.calculated_properties is not None:
            self.calculated_properties.export(outfile, level, namespace_, name_='calculated-properties', pretty_print=pretty_print)
        if self.experimental_properties is not None:
            self.experimental_properties.export(outfile, level, namespace_, name_='experimental-properties', pretty_print=pretty_print)
        if self.external_identifiers is not None:
            self.external_identifiers.export(outfile, level, namespace_, name_='external-identifiers', pretty_print=pretty_print)
        if self.external_links is not None:
            self.external_links.export(outfile, level, namespace_, name_='external-links', pretty_print=pretty_print)
        if self.pathways is not None:
            self.pathways.export(outfile, level, namespace_, name_='pathways', pretty_print=pretty_print)
        if self.reactions is not None:
            self.reactions.export(outfile, level, namespace_, name_='reactions', pretty_print=pretty_print)
        if self.snp_effects is not None:
            self.snp_effects.export(outfile, level, namespace_, name_='snp-effects', pretty_print=pretty_print)
        if self.snp_adverse_drug_reactions is not None:
            self.snp_adverse_drug_reactions.export(outfile, level, namespace_, name_='snp-adverse-drug-reactions', pretty_print=pretty_print)
        if self.targets is not None:
            self.targets.export(outfile, level, namespace_, name_='targets', pretty_print=pretty_print)
        if self.enzymes is not None:
            self.enzymes.export(outfile, level, namespace_, name_='enzymes', pretty_print=pretty_print)
        if self.carriers is not None:
            self.carriers.export(outfile, level, namespace_, name_='carriers', pretty_print=pretty_print)
        if self.transporters is not None:
            self.transporters.export(outfile, level, namespace_, name_='transporters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.add('created')
            try:
                self.created = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (created): %s' % exp)
        value = find_attr_value_('updated', node)
        if value is not None and 'updated' not in already_processed:
            already_processed.add('updated')
            try:
                self.updated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (updated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drugbank-id':
            obj_ = drugbank_drug_id_type.factory()
            obj_.build(child_)
            self.drugbank_id.append(obj_)
            obj_.original_tagname_ = 'drugbank-id'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'cas-number':
            cas_number_ = child_.text
            cas_number_ = self.gds_validate_string(cas_number_, node, 'cas_number')
            self.cas_number = cas_number_
        elif nodeName_ == 'groups':
            obj_ = group_list_type.factory()
            obj_.build(child_)
            self.groups = obj_
            obj_.original_tagname_ = 'groups'
        elif nodeName_ == 'general-references':
            general_references_ = child_.text
            general_references_ = self.gds_validate_string(general_references_, node, 'general_references')
            self.general_references = general_references_
        elif nodeName_ == 'synthesis-reference':
            synthesis_reference_ = child_.text
            synthesis_reference_ = self.gds_validate_string(synthesis_reference_, node, 'synthesis_reference')
            self.synthesis_reference = synthesis_reference_
        elif nodeName_ == 'indication':
            indication_ = child_.text
            indication_ = self.gds_validate_string(indication_, node, 'indication')
            self.indication = indication_
        elif nodeName_ == 'pharmacodynamics':
            pharmacodynamics_ = child_.text
            pharmacodynamics_ = self.gds_validate_string(pharmacodynamics_, node, 'pharmacodynamics')
            self.pharmacodynamics = pharmacodynamics_
        elif nodeName_ == 'mechanism-of-action':
            mechanism_of_action_ = child_.text
            mechanism_of_action_ = self.gds_validate_string(mechanism_of_action_, node, 'mechanism_of_action')
            self.mechanism_of_action = mechanism_of_action_
        elif nodeName_ == 'toxicity':
            toxicity_ = child_.text
            toxicity_ = self.gds_validate_string(toxicity_, node, 'toxicity')
            self.toxicity = toxicity_
        elif nodeName_ == 'metabolism':
            metabolism_ = child_.text
            metabolism_ = self.gds_validate_string(metabolism_, node, 'metabolism')
            self.metabolism = metabolism_
        elif nodeName_ == 'absorption':
            absorption_ = child_.text
            absorption_ = self.gds_validate_string(absorption_, node, 'absorption')
            self.absorption = absorption_
        elif nodeName_ == 'half-life':
            half_life_ = child_.text
            half_life_ = self.gds_validate_string(half_life_, node, 'half_life')
            self.half_life = half_life_
        elif nodeName_ == 'protein-binding':
            protein_binding_ = child_.text
            protein_binding_ = self.gds_validate_string(protein_binding_, node, 'protein_binding')
            self.protein_binding = protein_binding_
        elif nodeName_ == 'route-of-elimination':
            route_of_elimination_ = child_.text
            route_of_elimination_ = self.gds_validate_string(route_of_elimination_, node, 'route_of_elimination')
            self.route_of_elimination = route_of_elimination_
        elif nodeName_ == 'volume-of-distribution':
            volume_of_distribution_ = child_.text
            volume_of_distribution_ = self.gds_validate_string(volume_of_distribution_, node, 'volume_of_distribution')
            self.volume_of_distribution = volume_of_distribution_
        elif nodeName_ == 'clearance':
            clearance_ = child_.text
            clearance_ = self.gds_validate_string(clearance_, node, 'clearance')
            self.clearance = clearance_
        elif nodeName_ == 'classification':
            obj_ = classification_type.factory()
            obj_.build(child_)
            self.classification = obj_
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'salts':
            obj_ = salt_list_type.factory()
            obj_.build(child_)
            self.salts = obj_
            obj_.original_tagname_ = 'salts'
        elif nodeName_ == 'synonyms':
            obj_ = synonym_list_type.factory()
            obj_.build(child_)
            self.synonyms = obj_
            obj_.original_tagname_ = 'synonyms'
        elif nodeName_ == 'products':
            obj_ = product_list_type.factory()
            obj_.build(child_)
            self.products = obj_
            obj_.original_tagname_ = 'products'
        elif nodeName_ == 'international-brands':
            obj_ = international_brand_list_type.factory()
            obj_.build(child_)
            self.international_brands = obj_
            obj_.original_tagname_ = 'international-brands'
        elif nodeName_ == 'mixtures':
            obj_ = mixture_list_type.factory()
            obj_.build(child_)
            self.mixtures = obj_
            obj_.original_tagname_ = 'mixtures'
        elif nodeName_ == 'packagers':
            obj_ = packager_list_type.factory()
            obj_.build(child_)
            self.packagers = obj_
            obj_.original_tagname_ = 'packagers'
        elif nodeName_ == 'manufacturers':
            obj_ = manufacturer_list_type.factory()
            obj_.build(child_)
            self.manufacturers = obj_
            obj_.original_tagname_ = 'manufacturers'
        elif nodeName_ == 'prices':
            obj_ = price_list_type.factory()
            obj_.build(child_)
            self.prices = obj_
            obj_.original_tagname_ = 'prices'
        elif nodeName_ == 'categories':
            obj_ = category_list_type.factory()
            obj_.build(child_)
            self.categories = obj_
            obj_.original_tagname_ = 'categories'
        elif nodeName_ == 'affected-organisms':
            obj_ = affected_organism_list_type.factory()
            obj_.build(child_)
            self.affected_organisms = obj_
            obj_.original_tagname_ = 'affected-organisms'
        elif nodeName_ == 'dosages':
            obj_ = dosage_list_type.factory()
            obj_.build(child_)
            self.dosages = obj_
            obj_.original_tagname_ = 'dosages'
        elif nodeName_ == 'atc-codes':
            obj_ = atc_code_list_type.factory()
            obj_.build(child_)
            self.atc_codes = obj_
            obj_.original_tagname_ = 'atc-codes'
        elif nodeName_ == 'ahfs-codes':
            obj_ = ahfs_code_list_type.factory()
            obj_.build(child_)
            self.ahfs_codes = obj_
            obj_.original_tagname_ = 'ahfs-codes'
        elif nodeName_ == 'patents':
            obj_ = patent_list_type.factory()
            obj_.build(child_)
            self.patents = obj_
            obj_.original_tagname_ = 'patents'
        elif nodeName_ == 'food-interactions':
            obj_ = food_interaction_list_type.factory()
            obj_.build(child_)
            self.food_interactions = obj_
            obj_.original_tagname_ = 'food-interactions'
        elif nodeName_ == 'drug-interactions':
            obj_ = drug_interaction_list_type.factory()
            obj_.build(child_)
            self.drug_interactions = obj_
            obj_.original_tagname_ = 'drug-interactions'
        elif nodeName_ == 'sequences':
            obj_ = sequence_list_type.factory()
            obj_.build(child_)
            self.sequences = obj_
            obj_.original_tagname_ = 'sequences'
        elif nodeName_ == 'calculated-properties':
            obj_ = calculated_property_list_type.factory()
            obj_.build(child_)
            self.calculated_properties = obj_
            obj_.original_tagname_ = 'calculated-properties'
        elif nodeName_ == 'experimental-properties':
            obj_ = experimental_property_list_type.factory()
            obj_.build(child_)
            self.experimental_properties = obj_
            obj_.original_tagname_ = 'experimental-properties'
        elif nodeName_ == 'external-identifiers':
            obj_ = external_identifier_list_type.factory()
            obj_.build(child_)
            self.external_identifiers = obj_
            obj_.original_tagname_ = 'external-identifiers'
        elif nodeName_ == 'external-links':
            obj_ = external_link_list_type.factory()
            obj_.build(child_)
            self.external_links = obj_
            obj_.original_tagname_ = 'external-links'
        elif nodeName_ == 'pathways':
            obj_ = pathway_list_type.factory()
            obj_.build(child_)
            self.pathways = obj_
            obj_.original_tagname_ = 'pathways'
        elif nodeName_ == 'reactions':
            obj_ = reaction_list_type.factory()
            obj_.build(child_)
            self.reactions = obj_
            obj_.original_tagname_ = 'reactions'
        elif nodeName_ == 'snp-effects':
            obj_ = snp_effect_list_type.factory()
            obj_.build(child_)
            self.snp_effects = obj_
            obj_.original_tagname_ = 'snp-effects'
        elif nodeName_ == 'snp-adverse-drug-reactions':
            obj_ = snp_adverse_drug_reaction_list_type.factory()
            obj_.build(child_)
            self.snp_adverse_drug_reactions = obj_
            obj_.original_tagname_ = 'snp-adverse-drug-reactions'
        elif nodeName_ == 'targets':
            obj_ = target_list_type.factory()
            obj_.build(child_)
            self.targets = obj_
            obj_.original_tagname_ = 'targets'
        elif nodeName_ == 'enzymes':
            obj_ = enzyme_list_type.factory()
            obj_.build(child_)
            self.enzymes = obj_
            obj_.original_tagname_ = 'enzymes'
        elif nodeName_ == 'carriers':
            obj_ = carrier_list_type.factory()
            obj_.build(child_)
            self.carriers = obj_
            obj_.original_tagname_ = 'carriers'
        elif nodeName_ == 'transporters':
            obj_ = transporter_list_type.factory()
            obj_.build(child_)
            self.transporters = obj_
            obj_.original_tagname_ = 'transporters'
# end class drug_type


class group_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, group_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if group_list_type.subclass:
            return group_list_type.subclass(*args_, **kwargs_)
        else:
            return group_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def validate_group_type(self, value):
        # Validate type group-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['approved', 'illicit', 'experimental', 'withdrawn', 'nutraceutical', 'investigational']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on group-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='group-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='group-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='group-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='group-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='group-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(group_), input_name='group')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            # validate type group-type
            self.validate_group_type(self.group[-1])
# end class group_list_type


class classification_type(GeneratedsSuper):
    """Drug classification is obtained from ClassyFire
    (http://classyfire.wishartlab.com)."""
    subclass = None
    superclass = None
    def __init__(self, description=None, direct_parent=None, kingdom=None, superclass=None, class_=None, subclass=None, alternative_parent=None, substituent=None):
        self.original_tagname_ = None
        self.description = description
        self.direct_parent = direct_parent
        self.kingdom = kingdom
        self.superclass = superclass
        self.class_ = class_
        self.subclass = subclass
        if alternative_parent is None:
            self.alternative_parent = []
        else:
            self.alternative_parent = alternative_parent
        if substituent is None:
            self.substituent = []
        else:
            self.substituent = substituent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, classification_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if classification_type.subclass:
            return classification_type.subclass(*args_, **kwargs_)
        else:
            return classification_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_direct_parent(self): return self.direct_parent
    def set_direct_parent(self, direct_parent): self.direct_parent = direct_parent
    def get_kingdom(self): return self.kingdom
    def set_kingdom(self, kingdom): self.kingdom = kingdom
    def get_superclass(self): return self.superclass
    def set_superclass(self, superclass): self.superclass = superclass
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_subclass(self): return self.subclass
    def set_subclass(self, subclass): self.subclass = subclass
    def get_alternative_parent(self): return self.alternative_parent
    def set_alternative_parent(self, alternative_parent): self.alternative_parent = alternative_parent
    def add_alternative_parent(self, value): self.alternative_parent.append(value)
    def insert_alternative_parent_at(self, index, value): self.alternative_parent.insert(index, value)
    def replace_alternative_parent_at(self, index, value): self.alternative_parent[index] = value
    def get_substituent(self): return self.substituent
    def set_substituent(self, substituent): self.substituent = substituent
    def add_substituent(self, value): self.substituent.append(value)
    def insert_substituent_at(self, index, value): self.substituent.insert(index, value)
    def replace_substituent_at(self, index, value): self.substituent[index] = value
    def hasContent_(self):
        if (
            self.description is not None or
            self.direct_parent is not None or
            self.kingdom is not None or
            self.superclass is not None or
            self.class_ is not None or
            self.subclass is not None or
            self.alternative_parent or
            self.substituent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='classification-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='classification-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='classification-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='classification-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='classification-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.direct_parent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirect-parent>%s</%sdirect-parent>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.direct_parent), input_name='direct-parent')), namespace_, eol_))
        if self.kingdom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skingdom>%s</%skingdom>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.kingdom), input_name='kingdom')), namespace_, eol_))
        if self.superclass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssuperclass>%s</%ssuperclass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.superclass), input_name='superclass')), namespace_, eol_))
        if self.class_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclass>%s</%sclass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.class_), input_name='class')), namespace_, eol_))
        if self.subclass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubclass>%s</%ssubclass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.subclass), input_name='subclass')), namespace_, eol_))
        for alternative_parent_ in self.alternative_parent:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salternative-parent>%s</%salternative-parent>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(alternative_parent_), input_name='alternative-parent')), namespace_, eol_))
        for substituent_ in self.substituent:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubstituent>%s</%ssubstituent>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(substituent_), input_name='substituent')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'direct-parent':
            direct_parent_ = child_.text
            direct_parent_ = self.gds_validate_string(direct_parent_, node, 'direct_parent')
            self.direct_parent = direct_parent_
        elif nodeName_ == 'kingdom':
            kingdom_ = child_.text
            kingdom_ = self.gds_validate_string(kingdom_, node, 'kingdom')
            self.kingdom = kingdom_
        elif nodeName_ == 'superclass':
            superclass_ = child_.text
            superclass_ = self.gds_validate_string(superclass_, node, 'superclass')
            self.superclass = superclass_
        elif nodeName_ == 'class':
            class_ = child_.text
            class_ = self.gds_validate_string(class_, node, 'class')
            self.class_ = class_
        elif nodeName_ == 'subclass':
            subclass_ = child_.text
            subclass_ = self.gds_validate_string(subclass_, node, 'subclass')
            self.subclass = subclass_
        elif nodeName_ == 'alternative-parent':
            alternative_parent_ = child_.text
            alternative_parent_ = self.gds_validate_string(alternative_parent_, node, 'alternative_parent')
            self.alternative_parent.append(alternative_parent_)
        elif nodeName_ == 'substituent':
            substituent_ = child_.text
            substituent_ = self.gds_validate_string(substituent_, node, 'substituent')
            self.substituent.append(substituent_)
# end class classification_type


class synonym_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, synonym=None):
        self.original_tagname_ = None
        if synonym is None:
            self.synonym = []
        else:
            self.synonym = synonym
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, synonym_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if synonym_list_type.subclass:
            return synonym_list_type.subclass(*args_, **kwargs_)
        else:
            return synonym_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_synonym(self): return self.synonym
    def set_synonym(self, synonym): self.synonym = synonym
    def add_synonym(self, value): self.synonym.append(value)
    def insert_synonym_at(self, index, value): self.synonym.insert(index, value)
    def replace_synonym_at(self, index, value): self.synonym[index] = value
    def hasContent_(self):
        if (
            self.synonym
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='synonym-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='synonym-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='synonym-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='synonym-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='synonym-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for synonym_ in self.synonym:
            synonym_.export(outfile, level, namespace_, name_='synonym', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'synonym':
            obj_ = synonym_type.factory()
            obj_.build(child_)
            self.synonym.append(obj_)
            obj_.original_tagname_ = 'synonym'
# end class synonym_list_type


class synonym_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, language=None, coder=None, valueOf_=None):
        self.original_tagname_ = None
        self.language = _cast(None, language)
        self.coder = _cast(None, coder)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, synonym_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if synonym_type.subclass:
            return synonym_type.subclass(*args_, **kwargs_)
        else:
            return synonym_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_coder(self): return self.coder
    def set_coder(self, coder): self.coder = coder
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='synonym-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='synonym-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='synonym-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='synonym-type'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.coder is not None and 'coder' not in already_processed:
            already_processed.add('coder')
            outfile.write(' coder=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coder), input_name='coder')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='synonym-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('coder', node)
        if value is not None and 'coder' not in already_processed:
            already_processed.add('coder')
            self.coder = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class synonym_type


class salt_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, salt=None):
        self.original_tagname_ = None
        if salt is None:
            self.salt = []
        else:
            self.salt = salt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, salt_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if salt_list_type.subclass:
            return salt_list_type.subclass(*args_, **kwargs_)
        else:
            return salt_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_salt(self): return self.salt
    def set_salt(self, salt): self.salt = salt
    def add_salt(self, value): self.salt.append(value)
    def insert_salt_at(self, index, value): self.salt.insert(index, value)
    def replace_salt_at(self, index, value): self.salt[index] = value
    def hasContent_(self):
        if (
            self.salt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='salt-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='salt-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='salt-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='salt-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='salt-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for salt_ in self.salt:
            salt_.export(outfile, level, namespace_, name_='salt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'salt':
            obj_ = salt_type.factory()
            obj_.build(child_)
            self.salt.append(obj_)
            obj_.original_tagname_ = 'salt'
# end class salt_list_type


class salt_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drugbank_id=None, name=None, cas_number=None, inchikey=None):
        self.original_tagname_ = None
        if drugbank_id is None:
            self.drugbank_id = []
        else:
            self.drugbank_id = drugbank_id
        self.name = name
        self.cas_number = cas_number
        self.inchikey = inchikey
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, salt_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if salt_type.subclass:
            return salt_type.subclass(*args_, **kwargs_)
        else:
            return salt_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drugbank_id(self): return self.drugbank_id
    def set_drugbank_id(self, drugbank_id): self.drugbank_id = drugbank_id
    def add_drugbank_id(self, value): self.drugbank_id.append(value)
    def insert_drugbank_id_at(self, index, value): self.drugbank_id.insert(index, value)
    def replace_drugbank_id_at(self, index, value): self.drugbank_id[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_cas_number(self): return self.cas_number
    def set_cas_number(self, cas_number): self.cas_number = cas_number
    def get_inchikey(self): return self.inchikey
    def set_inchikey(self, inchikey): self.inchikey = inchikey
    def hasContent_(self):
        if (
            self.drugbank_id or
            self.name is not None or
            self.cas_number is not None or
            self.inchikey is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='salt-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='salt-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='salt-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='salt-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='salt-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for drugbank_id_ in self.drugbank_id:
            drugbank_id_.export(outfile, level, namespace_, name_='drugbank-id', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.cas_number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scas-number>%s</%scas-number>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cas_number), input_name='cas-number')), namespace_, eol_))
        if self.inchikey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinchikey>%s</%sinchikey>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.inchikey), input_name='inchikey')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drugbank-id':
            obj_ = drugbank_salt_id_type.factory()
            obj_.build(child_)
            self.drugbank_id.append(obj_)
            obj_.original_tagname_ = 'drugbank-id'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'cas-number':
            cas_number_ = child_.text
            cas_number_ = self.gds_validate_string(cas_number_, node, 'cas_number')
            self.cas_number = cas_number_
        elif nodeName_ == 'inchikey':
            inchikey_ = child_.text
            inchikey_ = self.gds_validate_string(inchikey_, node, 'inchikey')
            self.inchikey = inchikey_
# end class salt_type


class drugbank_drug_id_type(GeneratedsSuper):
    """The DrugBank ID is used to uniquely identify a drug entry. There is
    a primary ID and several secondary IDs that come from older ID
    formats or merged entries."""
    subclass = None
    superclass = None
    def __init__(self, primary=False, valueOf_=None):
        self.original_tagname_ = None
        self.primary = _cast(bool, primary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugbank_drug_id_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugbank_drug_id_type.subclass:
            return drugbank_drug_id_type.subclass(*args_, **kwargs_)
        else:
            return drugbank_drug_id_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primary(self): return self.primary
    def set_primary(self, primary): self.primary = primary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drugbank-drug-id-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drugbank-drug-id-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drugbank-drug-id-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drugbank-drug-id-type'):
        if self.primary and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary="%s"' % self.gds_format_boolean(self.primary, input_name='primary'))
    def exportChildren(self, outfile, level, namespace_='', name_='drugbank-drug-id-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            if value in ('true', '1'):
                self.primary = True
            elif value in ('false', '0'):
                self.primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class drugbank_drug_id_type


class drugbank_salt_id_type(GeneratedsSuper):
    """The salt DrugBank ID uniquely identifies a salt entry. Multiple IDs
    indicate a merged entry."""
    subclass = None
    superclass = None
    def __init__(self, primary=False, valueOf_=None):
        self.original_tagname_ = None
        self.primary = _cast(bool, primary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugbank_salt_id_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugbank_salt_id_type.subclass:
            return drugbank_salt_id_type.subclass(*args_, **kwargs_)
        else:
            return drugbank_salt_id_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primary(self): return self.primary
    def set_primary(self, primary): self.primary = primary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drugbank-salt-id-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drugbank-salt-id-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drugbank-salt-id-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drugbank-salt-id-type'):
        if self.primary and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary="%s"' % self.gds_format_boolean(self.primary, input_name='primary'))
    def exportChildren(self, outfile, level, namespace_='', name_='drugbank-salt-id-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            if value in ('true', '1'):
                self.primary = True
            elif value in ('false', '0'):
                self.primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class drugbank_salt_id_type


class drugbank_metabolite_id_type(GeneratedsSuper):
    """The metabolite DrugBank ID uniquely identifies a metabolite entry.
    Multiple IDs indicate a merged entry."""
    subclass = None
    superclass = None
    def __init__(self, primary=False, valueOf_=None):
        self.original_tagname_ = None
        self.primary = _cast(bool, primary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drugbank_metabolite_id_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drugbank_metabolite_id_type.subclass:
            return drugbank_metabolite_id_type.subclass(*args_, **kwargs_)
        else:
            return drugbank_metabolite_id_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primary(self): return self.primary
    def set_primary(self, primary): self.primary = primary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drugbank-metabolite-id-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drugbank-metabolite-id-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drugbank-metabolite-id-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drugbank-metabolite-id-type'):
        if self.primary and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary="%s"' % self.gds_format_boolean(self.primary, input_name='primary'))
    def exportChildren(self, outfile, level, namespace_='', name_='drugbank-metabolite-id-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            if value in ('true', '1'):
                self.primary = True
            elif value in ('false', '0'):
                self.primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class drugbank_metabolite_id_type


class international_brand_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, international_brand=None):
        self.original_tagname_ = None
        if international_brand is None:
            self.international_brand = []
        else:
            self.international_brand = international_brand
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, international_brand_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if international_brand_list_type.subclass:
            return international_brand_list_type.subclass(*args_, **kwargs_)
        else:
            return international_brand_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_international_brand(self): return self.international_brand
    def set_international_brand(self, international_brand): self.international_brand = international_brand
    def add_international_brand(self, value): self.international_brand.append(value)
    def insert_international_brand_at(self, index, value): self.international_brand.insert(index, value)
    def replace_international_brand_at(self, index, value): self.international_brand[index] = value
    def hasContent_(self):
        if (
            self.international_brand
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='international-brand-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='international-brand-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='international-brand-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='international-brand-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='international-brand-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for international_brand_ in self.international_brand:
            international_brand_.export(outfile, level, namespace_, name_='international-brand', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'international-brand':
            obj_ = international_brand_type.factory()
            obj_.build(child_)
            self.international_brand.append(obj_)
            obj_.original_tagname_ = 'international-brand'
# end class international_brand_list_type


class international_brand_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, company=None):
        self.original_tagname_ = None
        self.name = name
        self.company = company
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, international_brand_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if international_brand_type.subclass:
            return international_brand_type.subclass(*args_, **kwargs_)
        else:
            return international_brand_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_company(self): return self.company
    def set_company(self, company): self.company = company
    def hasContent_(self):
        if (
            self.name is not None or
            self.company is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='international-brand-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='international-brand-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='international-brand-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='international-brand-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='international-brand-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.company is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompany>%s</%scompany>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.company), input_name='company')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'company':
            company_ = child_.text
            company_ = self.gds_validate_string(company_, node, 'company')
            self.company = company_
# end class international_brand_type


class product_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, product=None):
        self.original_tagname_ = None
        if product is None:
            self.product = []
        else:
            self.product = product
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, product_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if product_list_type.subclass:
            return product_list_type.subclass(*args_, **kwargs_)
        else:
            return product_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def add_product(self, value): self.product.append(value)
    def insert_product_at(self, index, value): self.product.insert(index, value)
    def replace_product_at(self, index, value): self.product[index] = value
    def hasContent_(self):
        if (
            self.product
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='product-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='product-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='product-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='product-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='product-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for product_ in self.product:
            product_.export(outfile, level, namespace_, name_='product', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'product':
            obj_ = product_type.factory()
            obj_.build(child_)
            self.product.append(obj_)
            obj_.original_tagname_ = 'product'
# end class product_list_type


class product_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, ndc_id=None, ndc_product_code=None, dpd_id=None, started_marketing_on=None, ended_marketing_on=None, dosage_form=None, strength=None, route=None, fda_application_number=None, generic=None, over_the_counter=None, approved=None, country=None, source=None):
        self.original_tagname_ = None
        self.name = name
        self.ndc_id = ndc_id
        self.ndc_product_code = ndc_product_code
        self.dpd_id = dpd_id
        self.started_marketing_on = started_marketing_on
        self.ended_marketing_on = ended_marketing_on
        self.dosage_form = dosage_form
        self.strength = strength
        self.route = route
        self.fda_application_number = fda_application_number
        self.generic = generic
        self.over_the_counter = over_the_counter
        self.approved = approved
        self.country = country
        self.validate_product-country-type(self.country)
        self.source = source
        self.validate_product-source-type(self.source)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, product_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if product_type.subclass:
            return product_type.subclass(*args_, **kwargs_)
        else:
            return product_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_ndc_id(self): return self.ndc_id
    def set_ndc_id(self, ndc_id): self.ndc_id = ndc_id
    def get_ndc_product_code(self): return self.ndc_product_code
    def set_ndc_product_code(self, ndc_product_code): self.ndc_product_code = ndc_product_code
    def get_dpd_id(self): return self.dpd_id
    def set_dpd_id(self, dpd_id): self.dpd_id = dpd_id
    def get_started_marketing_on(self): return self.started_marketing_on
    def set_started_marketing_on(self, started_marketing_on): self.started_marketing_on = started_marketing_on
    def get_ended_marketing_on(self): return self.ended_marketing_on
    def set_ended_marketing_on(self, ended_marketing_on): self.ended_marketing_on = ended_marketing_on
    def get_dosage_form(self): return self.dosage_form
    def set_dosage_form(self, dosage_form): self.dosage_form = dosage_form
    def get_strength(self): return self.strength
    def set_strength(self, strength): self.strength = strength
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def get_fda_application_number(self): return self.fda_application_number
    def set_fda_application_number(self, fda_application_number): self.fda_application_number = fda_application_number
    def get_generic(self): return self.generic
    def set_generic(self, generic): self.generic = generic
    def get_over_the_counter(self): return self.over_the_counter
    def set_over_the_counter(self, over_the_counter): self.over_the_counter = over_the_counter
    def get_approved(self): return self.approved
    def set_approved(self, approved): self.approved = approved
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def validate_product_country_type(self, value):
        # Validate type product-country-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['US', 'Canada']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on product-country-type' % {"value" : value.encode("utf-8")} )
    def validate_product_source_type(self, value):
        # Validate type product-source-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FDA NDC', 'DPD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on product-source-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.ndc_id is not None or
            self.ndc_product_code is not None or
            self.dpd_id is not None or
            self.started_marketing_on is not None or
            self.ended_marketing_on is not None or
            self.dosage_form is not None or
            self.strength is not None or
            self.route is not None or
            self.fda_application_number is not None or
            self.generic is not None or
            self.over_the_counter is not None or
            self.approved is not None or
            self.country is not None or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='product-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='product-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='product-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='product-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='product-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.ndc_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sndc-id>%s</%sndc-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ndc_id), input_name='ndc-id')), namespace_, eol_))
        if self.ndc_product_code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sndc-product-code>%s</%sndc-product-code>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ndc_product_code), input_name='ndc-product-code')), namespace_, eol_))
        if self.dpd_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdpd-id>%s</%sdpd-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dpd_id), input_name='dpd-id')), namespace_, eol_))
        if self.started_marketing_on is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstarted-marketing-on>%s</%sstarted-marketing-on>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.started_marketing_on), input_name='started-marketing-on')), namespace_, eol_))
        if self.ended_marketing_on is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sended-marketing-on>%s</%sended-marketing-on>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ended_marketing_on), input_name='ended-marketing-on')), namespace_, eol_))
        if self.dosage_form is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdosage-form>%s</%sdosage-form>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dosage_form), input_name='dosage-form')), namespace_, eol_))
        if self.strength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrength>%s</%sstrength>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.strength), input_name='strength')), namespace_, eol_))
        if self.route is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute>%s</%sroute>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.route), input_name='route')), namespace_, eol_))
        if self.fda_application_number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfda-application-number>%s</%sfda-application-number>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fda_application_number), input_name='fda-application-number')), namespace_, eol_))
        if self.generic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeneric>%s</%sgeneric>%s' % (namespace_, self.gds_format_boolean(self.generic, input_name='generic'), namespace_, eol_))
        if self.over_the_counter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sover-the-counter>%s</%sover-the-counter>%s' % (namespace_, self.gds_format_boolean(self.over_the_counter, input_name='over-the-counter'), namespace_, eol_))
        if self.approved is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapproved>%s</%sapproved>%s' % (namespace_, self.gds_format_boolean(self.approved, input_name='approved'), namespace_, eol_))
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.country), input_name='country')), namespace_, eol_))
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'ndc-id':
            ndc_id_ = child_.text
            ndc_id_ = self.gds_validate_string(ndc_id_, node, 'ndc_id')
            self.ndc_id = ndc_id_
        elif nodeName_ == 'ndc-product-code':
            ndc_product_code_ = child_.text
            ndc_product_code_ = self.gds_validate_string(ndc_product_code_, node, 'ndc_product_code')
            self.ndc_product_code = ndc_product_code_
        elif nodeName_ == 'dpd-id':
            dpd_id_ = child_.text
            dpd_id_ = self.gds_validate_string(dpd_id_, node, 'dpd_id')
            self.dpd_id = dpd_id_
        elif nodeName_ == 'started-marketing-on':
            started_marketing_on_ = child_.text
            started_marketing_on_ = self.gds_validate_string(started_marketing_on_, node, 'started_marketing_on')
            self.started_marketing_on = started_marketing_on_
        elif nodeName_ == 'ended-marketing-on':
            ended_marketing_on_ = child_.text
            ended_marketing_on_ = self.gds_validate_string(ended_marketing_on_, node, 'ended_marketing_on')
            self.ended_marketing_on = ended_marketing_on_
        elif nodeName_ == 'dosage-form':
            dosage_form_ = child_.text
            dosage_form_ = self.gds_validate_string(dosage_form_, node, 'dosage_form')
            self.dosage_form = dosage_form_
        elif nodeName_ == 'strength':
            strength_ = child_.text
            strength_ = self.gds_validate_string(strength_, node, 'strength')
            self.strength = strength_
        elif nodeName_ == 'route':
            route_ = child_.text
            route_ = self.gds_validate_string(route_, node, 'route')
            self.route = route_
        elif nodeName_ == 'fda-application-number':
            fda_application_number_ = child_.text
            fda_application_number_ = self.gds_validate_string(fda_application_number_, node, 'fda_application_number')
            self.fda_application_number = fda_application_number_
        elif nodeName_ == 'generic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'generic')
            self.generic = ival_
        elif nodeName_ == 'over-the-counter':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'over_the_counter')
            self.over_the_counter = ival_
        elif nodeName_ == 'approved':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'approved')
            self.approved = ival_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
            # validate type product-country-type
            self.validate_product_country_type(self.country)
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
            # validate type product-source-type
            self.validate_product_source_type(self.source)
# end class product_type


class mixture_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mixture=None):
        self.original_tagname_ = None
        if mixture is None:
            self.mixture = []
        else:
            self.mixture = mixture
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mixture_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mixture_list_type.subclass:
            return mixture_list_type.subclass(*args_, **kwargs_)
        else:
            return mixture_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mixture(self): return self.mixture
    def set_mixture(self, mixture): self.mixture = mixture
    def add_mixture(self, value): self.mixture.append(value)
    def insert_mixture_at(self, index, value): self.mixture.insert(index, value)
    def replace_mixture_at(self, index, value): self.mixture[index] = value
    def hasContent_(self):
        if (
            self.mixture
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mixture-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mixture-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mixture-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mixture-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mixture-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mixture_ in self.mixture:
            mixture_.export(outfile, level, namespace_, name_='mixture', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mixture':
            obj_ = mixture_type.factory()
            obj_.build(child_)
            self.mixture.append(obj_)
            obj_.original_tagname_ = 'mixture'
# end class mixture_list_type


class mixture_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, ingredients=None):
        self.original_tagname_ = None
        self.name = name
        self.ingredients = ingredients
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mixture_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mixture_type.subclass:
            return mixture_type.subclass(*args_, **kwargs_)
        else:
            return mixture_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_ingredients(self): return self.ingredients
    def set_ingredients(self, ingredients): self.ingredients = ingredients
    def hasContent_(self):
        if (
            self.name is not None or
            self.ingredients is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mixture-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mixture-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mixture-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mixture-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mixture-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.ingredients is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%singredients>%s</%singredients>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ingredients), input_name='ingredients')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'ingredients':
            ingredients_ = child_.text
            ingredients_ = self.gds_validate_string(ingredients_, node, 'ingredients')
            self.ingredients = ingredients_
# end class mixture_type


class packager_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, packager=None):
        self.original_tagname_ = None
        if packager is None:
            self.packager = []
        else:
            self.packager = packager
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packager_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packager_list_type.subclass:
            return packager_list_type.subclass(*args_, **kwargs_)
        else:
            return packager_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_packager(self): return self.packager
    def set_packager(self, packager): self.packager = packager
    def add_packager(self, value): self.packager.append(value)
    def insert_packager_at(self, index, value): self.packager.insert(index, value)
    def replace_packager_at(self, index, value): self.packager[index] = value
    def hasContent_(self):
        if (
            self.packager
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='packager-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packager-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='packager-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='packager-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='packager-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for packager_ in self.packager:
            packager_.export(outfile, level, namespace_, name_='packager', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'packager':
            obj_ = packager_type.factory()
            obj_.build(child_)
            self.packager.append(obj_)
            obj_.original_tagname_ = 'packager'
# end class packager_list_type


class packager_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, url=None):
        self.original_tagname_ = None
        self.name = name
        self.url = url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packager_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packager_type.subclass:
            return packager_type.subclass(*args_, **kwargs_)
        else:
            return packager_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def hasContent_(self):
        if (
            self.name is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='packager-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packager-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='packager-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='packager-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='packager-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
# end class packager_type


class manufacturer_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, manufacturer=None):
        self.original_tagname_ = None
        if manufacturer is None:
            self.manufacturer = []
        else:
            self.manufacturer = manufacturer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, manufacturer_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if manufacturer_list_type.subclass:
            return manufacturer_list_type.subclass(*args_, **kwargs_)
        else:
            return manufacturer_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manufacturer(self): return self.manufacturer
    def set_manufacturer(self, manufacturer): self.manufacturer = manufacturer
    def add_manufacturer(self, value): self.manufacturer.append(value)
    def insert_manufacturer_at(self, index, value): self.manufacturer.insert(index, value)
    def replace_manufacturer_at(self, index, value): self.manufacturer[index] = value
    def hasContent_(self):
        if (
            self.manufacturer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='manufacturer-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='manufacturer-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='manufacturer-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='manufacturer-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='manufacturer-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for manufacturer_ in self.manufacturer:
            manufacturer_.export(outfile, level, namespace_, name_='manufacturer', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manufacturer':
            obj_ = manufacturer_type.factory()
            obj_.build(child_)
            self.manufacturer.append(obj_)
            obj_.original_tagname_ = 'manufacturer'
# end class manufacturer_list_type


class manufacturer_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, generic=None, valueOf_=None):
        self.original_tagname_ = None
        self.generic = _cast(bool, generic)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, manufacturer_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if manufacturer_type.subclass:
            return manufacturer_type.subclass(*args_, **kwargs_)
        else:
            return manufacturer_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generic(self): return self.generic
    def set_generic(self, generic): self.generic = generic
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='manufacturer-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='manufacturer-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='manufacturer-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='manufacturer-type'):
        if self.generic is not None and 'generic' not in already_processed:
            already_processed.add('generic')
            outfile.write(' generic="%s"' % self.gds_format_boolean(self.generic, input_name='generic'))
    def exportChildren(self, outfile, level, namespace_='', name_='manufacturer-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generic', node)
        if value is not None and 'generic' not in already_processed:
            already_processed.add('generic')
            if value in ('true', '1'):
                self.generic = True
            elif value in ('false', '0'):
                self.generic = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class manufacturer_type


class price_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, price=None):
        self.original_tagname_ = None
        if price is None:
            self.price = []
        else:
            self.price = price
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, price_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if price_list_type.subclass:
            return price_list_type.subclass(*args_, **kwargs_)
        else:
            return price_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_price(self): return self.price
    def set_price(self, price): self.price = price
    def add_price(self, value): self.price.append(value)
    def insert_price_at(self, index, value): self.price.insert(index, value)
    def replace_price_at(self, index, value): self.price[index] = value
    def hasContent_(self):
        if (
            self.price
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='price-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='price-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='price-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='price-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='price-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for price_ in self.price:
            price_.export(outfile, level, namespace_, name_='price', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'price':
            obj_ = price_type.factory()
            obj_.build(child_)
            self.price.append(obj_)
            obj_.original_tagname_ = 'price'
# end class price_list_type


class price_type(GeneratedsSuper):
    """The price for the given drug in US or Canadian currency."""
    subclass = None
    superclass = None
    def __init__(self, description=None, cost=None, unit=None):
        self.original_tagname_ = None
        self.description = description
        self.cost = cost
        self.unit = unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, price_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if price_type.subclass:
            return price_type.subclass(*args_, **kwargs_)
        else:
            return price_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_cost(self): return self.cost
    def set_cost(self, cost): self.cost = cost
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def hasContent_(self):
        if (
            self.description is not None or
            self.cost is not None or
            self.unit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='price-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='price-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='price-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='price-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='price-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.cost is not None:
            self.cost.export(outfile, level, namespace_, name_='cost', pretty_print=pretty_print)
        if self.unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunit>%s</%sunit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.unit), input_name='unit')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'cost':
            obj_ = costType.factory()
            obj_.build(child_)
            self.cost = obj_
            obj_.original_tagname_ = 'cost'
        elif nodeName_ == 'unit':
            unit_ = child_.text
            unit_ = self.gds_validate_string(unit_, node, 'unit')
            self.unit = unit_
# end class price_type


class category_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, category=None):
        self.original_tagname_ = None
        if category is None:
            self.category = []
        else:
            self.category = category
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, category_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if category_list_type.subclass:
            return category_list_type.subclass(*args_, **kwargs_)
        else:
            return category_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category_at(self, index, value): self.category.insert(index, value)
    def replace_category_at(self, index, value): self.category[index] = value
    def hasContent_(self):
        if (
            self.category
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='category-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='category-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='category-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='category-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='category-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = category_type.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
# end class category_list_type


class category_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, category=None, mesh_id=None):
        self.original_tagname_ = None
        self.category = category
        self.mesh_id = mesh_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, category_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if category_type.subclass:
            return category_type.subclass(*args_, **kwargs_)
        else:
            return category_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_mesh_id(self): return self.mesh_id
    def set_mesh_id(self, mesh_id): self.mesh_id = mesh_id
    def hasContent_(self):
        if (
            self.category is not None or
            self.mesh_id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='category-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='category-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='category-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='category-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='category-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scategory>%s</%scategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.category), input_name='category')), namespace_, eol_))
        if self.mesh_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smesh-id>%s</%smesh-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mesh_id), input_name='mesh-id')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            category_ = child_.text
            category_ = self.gds_validate_string(category_, node, 'category')
            self.category = category_
        elif nodeName_ == 'mesh-id':
            mesh_id_ = child_.text
            mesh_id_ = self.gds_validate_string(mesh_id_, node, 'mesh_id')
            self.mesh_id = mesh_id_
# end class category_type


class affected_organism_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, affected_organism=None):
        self.original_tagname_ = None
        if affected_organism is None:
            self.affected_organism = []
        else:
            self.affected_organism = affected_organism
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, affected_organism_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if affected_organism_list_type.subclass:
            return affected_organism_list_type.subclass(*args_, **kwargs_)
        else:
            return affected_organism_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_affected_organism(self): return self.affected_organism
    def set_affected_organism(self, affected_organism): self.affected_organism = affected_organism
    def add_affected_organism(self, value): self.affected_organism.append(value)
    def insert_affected_organism_at(self, index, value): self.affected_organism.insert(index, value)
    def replace_affected_organism_at(self, index, value): self.affected_organism[index] = value
    def hasContent_(self):
        if (
            self.affected_organism
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='affected-organism-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='affected-organism-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='affected-organism-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='affected-organism-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='affected-organism-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for affected_organism_ in self.affected_organism:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saffected-organism>%s</%saffected-organism>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(affected_organism_), input_name='affected-organism')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'affected-organism':
            affected_organism_ = child_.text
            affected_organism_ = self.gds_validate_string(affected_organism_, node, 'affected_organism')
            self.affected_organism.append(affected_organism_)
# end class affected_organism_list_type


class dosage_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dosage=None):
        self.original_tagname_ = None
        if dosage is None:
            self.dosage = []
        else:
            self.dosage = dosage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dosage_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dosage_list_type.subclass:
            return dosage_list_type.subclass(*args_, **kwargs_)
        else:
            return dosage_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dosage(self): return self.dosage
    def set_dosage(self, dosage): self.dosage = dosage
    def add_dosage(self, value): self.dosage.append(value)
    def insert_dosage_at(self, index, value): self.dosage.insert(index, value)
    def replace_dosage_at(self, index, value): self.dosage[index] = value
    def hasContent_(self):
        if (
            self.dosage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dosage-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dosage-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dosage-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dosage-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dosage-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dosage_ in self.dosage:
            dosage_.export(outfile, level, namespace_, name_='dosage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dosage':
            obj_ = dosage_type.factory()
            obj_.build(child_)
            self.dosage.append(obj_)
            obj_.original_tagname_ = 'dosage'
# end class dosage_list_type


class dosage_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, form=None, route=None, strength=None):
        self.original_tagname_ = None
        self.form = form
        self.route = route
        self.strength = strength
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dosage_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dosage_type.subclass:
            return dosage_type.subclass(*args_, **kwargs_)
        else:
            return dosage_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_form(self): return self.form
    def set_form(self, form): self.form = form
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def get_strength(self): return self.strength
    def set_strength(self, strength): self.strength = strength
    def hasContent_(self):
        if (
            self.form is not None or
            self.route is not None or
            self.strength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dosage-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dosage-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dosage-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dosage-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dosage-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.form is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sform>%s</%sform>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.form), input_name='form')), namespace_, eol_))
        if self.route is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute>%s</%sroute>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.route), input_name='route')), namespace_, eol_))
        if self.strength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrength>%s</%sstrength>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.strength), input_name='strength')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'form':
            form_ = child_.text
            form_ = self.gds_validate_string(form_, node, 'form')
            self.form = form_
        elif nodeName_ == 'route':
            route_ = child_.text
            route_ = self.gds_validate_string(route_, node, 'route')
            self.route = route_
        elif nodeName_ == 'strength':
            strength_ = child_.text
            strength_ = self.gds_validate_string(strength_, node, 'strength')
            self.strength = strength_
# end class dosage_type


class atc_code_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, atc_code=None):
        self.original_tagname_ = None
        if atc_code is None:
            self.atc_code = []
        else:
            self.atc_code = atc_code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atc_code_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atc_code_list_type.subclass:
            return atc_code_list_type.subclass(*args_, **kwargs_)
        else:
            return atc_code_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atc_code(self): return self.atc_code
    def set_atc_code(self, atc_code): self.atc_code = atc_code
    def add_atc_code(self, value): self.atc_code.append(value)
    def insert_atc_code_at(self, index, value): self.atc_code.insert(index, value)
    def replace_atc_code_at(self, index, value): self.atc_code[index] = value
    def hasContent_(self):
        if (
            self.atc_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='atc-code-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='atc-code-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='atc-code-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='atc-code-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='atc-code-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for atc_code_ in self.atc_code:
            atc_code_.export(outfile, level, namespace_, name_='atc-code', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'atc-code':
            obj_ = atc_code_type.factory()
            obj_.build(child_)
            self.atc_code.append(obj_)
            obj_.original_tagname_ = 'atc-code'
# end class atc_code_list_type


class atc_code_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, level=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        if level is None:
            self.level = []
        else:
            self.level = level
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atc_code_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atc_code_type.subclass:
            return atc_code_type.subclass(*args_, **kwargs_)
        else:
            return atc_code_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def add_level(self, value): self.level.append(value)
    def insert_level_at(self, index, value): self.level.insert(index, value)
    def replace_level_at(self, index, value): self.level[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def hasContent_(self):
        if (
            self.level
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='atc-code-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='atc-code-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='atc-code-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='atc-code-type'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='atc-code-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for level_ in self.level:
            level_.export(outfile, level, namespace_, name_='level', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'level':
            obj_ = atc_code_level_type.factory()
            obj_.build(child_)
            self.level.append(obj_)
            obj_.original_tagname_ = 'level'
# end class atc_code_type


class atc_code_level_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, valueOf_=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atc_code_level_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atc_code_level_type.subclass:
            return atc_code_level_type.subclass(*args_, **kwargs_)
        else:
            return atc_code_level_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='atc-code-level-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='atc-code-level-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='atc-code-level-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='atc-code-level-type'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='atc-code-level-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class atc_code_level_type


class ahfs_code_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ahfs_code=None):
        self.original_tagname_ = None
        if ahfs_code is None:
            self.ahfs_code = []
        else:
            self.ahfs_code = ahfs_code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ahfs_code_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ahfs_code_list_type.subclass:
            return ahfs_code_list_type.subclass(*args_, **kwargs_)
        else:
            return ahfs_code_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ahfs_code(self): return self.ahfs_code
    def set_ahfs_code(self, ahfs_code): self.ahfs_code = ahfs_code
    def add_ahfs_code(self, value): self.ahfs_code.append(value)
    def insert_ahfs_code_at(self, index, value): self.ahfs_code.insert(index, value)
    def replace_ahfs_code_at(self, index, value): self.ahfs_code[index] = value
    def hasContent_(self):
        if (
            self.ahfs_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ahfs-code-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ahfs-code-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ahfs-code-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ahfs-code-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ahfs-code-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ahfs_code_ in self.ahfs_code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sahfs-code>%s</%sahfs-code>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(ahfs_code_), input_name='ahfs-code')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ahfs-code':
            ahfs_code_ = child_.text
            ahfs_code_ = self.gds_validate_string(ahfs_code_, node, 'ahfs_code')
            self.ahfs_code.append(ahfs_code_)
# end class ahfs_code_list_type


class patent_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, patent=None):
        self.original_tagname_ = None
        if patent is None:
            self.patent = []
        else:
            self.patent = patent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, patent_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if patent_list_type.subclass:
            return patent_list_type.subclass(*args_, **kwargs_)
        else:
            return patent_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_patent(self): return self.patent
    def set_patent(self, patent): self.patent = patent
    def add_patent(self, value): self.patent.append(value)
    def insert_patent_at(self, index, value): self.patent.insert(index, value)
    def replace_patent_at(self, index, value): self.patent[index] = value
    def hasContent_(self):
        if (
            self.patent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='patent-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='patent-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='patent-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='patent-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='patent-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for patent_ in self.patent:
            patent_.export(outfile, level, namespace_, name_='patent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'patent':
            obj_ = patent_type.factory()
            obj_.build(child_)
            self.patent.append(obj_)
            obj_.original_tagname_ = 'patent'
# end class patent_list_type


class patent_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, country=None, approved=None, expires=None):
        self.original_tagname_ = None
        self.number = number
        self.country = country
        self.approved = approved
        self.expires = expires
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, patent_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if patent_type.subclass:
            return patent_type.subclass(*args_, **kwargs_)
        else:
            return patent_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_approved(self): return self.approved
    def set_approved(self, approved): self.approved = approved
    def get_expires(self): return self.expires
    def set_expires(self, expires): self.expires = expires
    def hasContent_(self):
        if (
            self.number is not None or
            self.country is not None or
            self.approved is not None or
            self.expires is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='patent-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='patent-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='patent-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='patent-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='patent-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespace_, eol_))
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.country), input_name='country')), namespace_, eol_))
        if self.approved is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapproved>%s</%sapproved>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.approved), input_name='approved')), namespace_, eol_))
        if self.expires is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpires>%s</%sexpires>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.expires), input_name='expires')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'number':
            number_ = child_.text
            number_ = self.gds_validate_string(number_, node, 'number')
            self.number = number_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'approved':
            approved_ = child_.text
            approved_ = self.gds_validate_string(approved_, node, 'approved')
            self.approved = approved_
        elif nodeName_ == 'expires':
            expires_ = child_.text
            expires_ = self.gds_validate_string(expires_, node, 'expires')
            self.expires = expires_
# end class patent_type


class food_interaction_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, food_interaction=None):
        self.original_tagname_ = None
        if food_interaction is None:
            self.food_interaction = []
        else:
            self.food_interaction = food_interaction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, food_interaction_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if food_interaction_list_type.subclass:
            return food_interaction_list_type.subclass(*args_, **kwargs_)
        else:
            return food_interaction_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_food_interaction(self): return self.food_interaction
    def set_food_interaction(self, food_interaction): self.food_interaction = food_interaction
    def add_food_interaction(self, value): self.food_interaction.append(value)
    def insert_food_interaction_at(self, index, value): self.food_interaction.insert(index, value)
    def replace_food_interaction_at(self, index, value): self.food_interaction[index] = value
    def hasContent_(self):
        if (
            self.food_interaction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='food-interaction-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='food-interaction-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='food-interaction-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='food-interaction-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='food-interaction-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for food_interaction_ in self.food_interaction:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfood-interaction>%s</%sfood-interaction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(food_interaction_), input_name='food-interaction')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'food-interaction':
            food_interaction_ = child_.text
            food_interaction_ = self.gds_validate_string(food_interaction_, node, 'food_interaction')
            self.food_interaction.append(food_interaction_)
# end class food_interaction_list_type


class drug_interaction_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drug_interaction=None):
        self.original_tagname_ = None
        if drug_interaction is None:
            self.drug_interaction = []
        else:
            self.drug_interaction = drug_interaction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drug_interaction_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drug_interaction_list_type.subclass:
            return drug_interaction_list_type.subclass(*args_, **kwargs_)
        else:
            return drug_interaction_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drug_interaction(self): return self.drug_interaction
    def set_drug_interaction(self, drug_interaction): self.drug_interaction = drug_interaction
    def add_drug_interaction(self, value): self.drug_interaction.append(value)
    def insert_drug_interaction_at(self, index, value): self.drug_interaction.insert(index, value)
    def replace_drug_interaction_at(self, index, value): self.drug_interaction[index] = value
    def hasContent_(self):
        if (
            self.drug_interaction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drug-interaction-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drug-interaction-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drug-interaction-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drug-interaction-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='drug-interaction-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for drug_interaction_ in self.drug_interaction:
            drug_interaction_.export(outfile, level, namespace_, name_='drug-interaction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drug-interaction':
            obj_ = drug_interaction_type.factory()
            obj_.build(child_)
            self.drug_interaction.append(obj_)
            obj_.original_tagname_ = 'drug-interaction'
# end class drug_interaction_list_type


class drug_interaction_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drugbank_id=None, name=None, description=None):
        self.original_tagname_ = None
        self.drugbank_id = drugbank_id
        self.name = name
        self.description = description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drug_interaction_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drug_interaction_type.subclass:
            return drug_interaction_type.subclass(*args_, **kwargs_)
        else:
            return drug_interaction_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drugbank_id(self): return self.drugbank_id
    def set_drugbank_id(self, drugbank_id): self.drugbank_id = drugbank_id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.drugbank_id is not None or
            self.name is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='drug-interaction-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drug-interaction-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='drug-interaction-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drug-interaction-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='drug-interaction-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drugbank_id is not None:
            self.drugbank_id.export(outfile, level, namespace_, name_='drugbank-id', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drugbank-id':
            obj_ = drugbank_drug_id_type.factory()
            obj_.build(child_)
            self.drugbank_id = obj_
            obj_.original_tagname_ = 'drugbank-id'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
# end class drug_interaction_type


class sequence_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequence=None):
        self.original_tagname_ = None
        if sequence is None:
            self.sequence = []
        else:
            self.sequence = sequence
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sequence_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sequence_list_type.subclass:
            return sequence_list_type.subclass(*args_, **kwargs_)
        else:
            return sequence_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def add_sequence(self, value): self.sequence.append(value)
    def insert_sequence_at(self, index, value): self.sequence.insert(index, value)
    def replace_sequence_at(self, index, value): self.sequence[index] = value
    def hasContent_(self):
        if (
            self.sequence
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequence-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequence-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequence-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequence-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sequence-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sequence_ in self.sequence:
            sequence_.export(outfile, level, namespace_, name_='sequence', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequence':
            obj_ = sequenceType.factory()
            obj_.build(child_)
            self.sequence.append(obj_)
            obj_.original_tagname_ = 'sequence'
# end class sequence_list_type


class calculated_property_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None):
        self.original_tagname_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, calculated_property_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if calculated_property_list_type.subclass:
            return calculated_property_list_type.subclass(*args_, **kwargs_)
        else:
            return calculated_property_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='calculated-property-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calculated-property-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='calculated-property-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='calculated-property-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='calculated-property-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = calculated_property_type.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class calculated_property_list_type


class calculated_property_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kind=None, value=None, source=None):
        self.original_tagname_ = None
        self.kind = kind
        self.validate_calculated-property-kind-type(self.kind)
        self.value = value
        self.source = source
        self.validate_calculated-property-source-type(self.source)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, calculated_property_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if calculated_property_type.subclass:
            return calculated_property_type.subclass(*args_, **kwargs_)
        else:
            return calculated_property_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def validate_calculated_property_kind_type(self, value):
        # Validate type calculated-property-kind-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['logP', 'logS', 'Water Solubility', 'IUPAC Name', 'Traditional IUPAC Name', 'Molecular Weight', 'Monoisotopic Weight', 'SMILES', 'Molecular Formula', 'InChI', 'InChIKey', 'Polar Surface Area (PSA)', 'Refractivity', 'Polarizability', 'Rotatable Bond Count', 'H Bond Acceptor Count', 'H Bond Donor Count', 'pKa (strongest acidic)', 'pKa (strongest basic)', 'Physiological Charge', 'Number of Rings', 'Bioavailability', 'Rule of Five', 'Ghose Filter', 'MDDR-Like Rule']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on calculated-property-kind-type' % {"value" : value.encode("utf-8")} )
    def validate_calculated_property_source_type(self, value):
        # Validate type calculated-property-source-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ChemAxon', 'ALOGPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on calculated-property-source-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.kind is not None or
            self.value is not None or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='calculated-property-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calculated-property-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='calculated-property-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='calculated-property-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='calculated-property-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skind>%s</%skind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.kind), input_name='kind')), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespace_, eol_))
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kind':
            kind_ = child_.text
            kind_ = self.gds_validate_string(kind_, node, 'kind')
            self.kind = kind_
            # validate type calculated-property-kind-type
            self.validate_calculated_property_kind_type(self.kind)
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
            # validate type calculated-property-source-type
            self.validate_calculated_property_source_type(self.source)
# end class calculated_property_type


class experimental_property_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None):
        self.original_tagname_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, experimental_property_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if experimental_property_list_type.subclass:
            return experimental_property_list_type.subclass(*args_, **kwargs_)
        else:
            return experimental_property_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='experimental-property-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='experimental-property-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='experimental-property-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='experimental-property-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='experimental-property-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = experimental_property_type.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class experimental_property_list_type


class experimental_property_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kind=None, value=None, source=None):
        self.original_tagname_ = None
        self.kind = kind
        self.validate_experimental-property-kind-type(self.kind)
        self.value = value
        self.source = source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, experimental_property_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if experimental_property_type.subclass:
            return experimental_property_type.subclass(*args_, **kwargs_)
        else:
            return experimental_property_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def validate_experimental_property_kind_type(self, value):
        # Validate type experimental-property-kind-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Water Solubility', 'Melting Point', 'Boiling Point', 'logP', 'logS', 'Hydrophobicity', 'Isoelectric Point', 'caco2 Permeability', 'pKa', 'Molecular Weight', 'Molecular Formula']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on experimental-property-kind-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.kind is not None or
            self.value is not None or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='experimental-property-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='experimental-property-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='experimental-property-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='experimental-property-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='experimental-property-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skind>%s</%skind>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.kind), input_name='kind')), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespace_, eol_))
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kind':
            kind_ = child_.text
            kind_ = self.gds_validate_string(kind_, node, 'kind')
            self.kind = kind_
            # validate type experimental-property-kind-type
            self.validate_experimental_property_kind_type(self.kind)
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
# end class experimental_property_type


class external_identifier_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, external_identifier=None):
        self.original_tagname_ = None
        if external_identifier is None:
            self.external_identifier = []
        else:
            self.external_identifier = external_identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, external_identifier_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if external_identifier_list_type.subclass:
            return external_identifier_list_type.subclass(*args_, **kwargs_)
        else:
            return external_identifier_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_identifier(self): return self.external_identifier
    def set_external_identifier(self, external_identifier): self.external_identifier = external_identifier
    def add_external_identifier(self, value): self.external_identifier.append(value)
    def insert_external_identifier_at(self, index, value): self.external_identifier.insert(index, value)
    def replace_external_identifier_at(self, index, value): self.external_identifier[index] = value
    def hasContent_(self):
        if (
            self.external_identifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='external-identifier-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='external-identifier-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='external-identifier-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='external-identifier-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='external-identifier-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_identifier_ in self.external_identifier:
            external_identifier_.export(outfile, level, namespace_, name_='external-identifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external-identifier':
            obj_ = external_identifier_type.factory()
            obj_.build(child_)
            self.external_identifier.append(obj_)
            obj_.original_tagname_ = 'external-identifier'
# end class external_identifier_list_type


class external_identifier_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resource=None, identifier=None):
        self.original_tagname_ = None
        self.resource = resource
        self.validate_external-identifier-resource-type(self.resource)
        self.identifier = identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, external_identifier_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if external_identifier_type.subclass:
            return external_identifier_type.subclass(*args_, **kwargs_)
        else:
            return external_identifier_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def validate_external_identifier_resource_type(self, value):
        # Validate type external-identifier-resource-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UniProtKB', 'Wikipedia', 'ChEBI', 'PubChem Compound', 'PubChem Substance', 'Drugs Product Database (DPD)', 'KEGG Compound', 'KEGG Drug', 'ChemSpider', 'BindingDB', 'National Drug Code Directory', 'GenBank', 'PharmGKB', 'PDB', 'IUPHAR', 'Guide to Pharmacology']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on external-identifier-resource-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.resource is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='external-identifier-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='external-identifier-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='external-identifier-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='external-identifier-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='external-identifier-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresource>%s</%sresource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.resource), input_name='resource')), namespace_, eol_))
        if self.identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.identifier), input_name='identifier')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resource':
            resource_ = child_.text
            resource_ = self.gds_validate_string(resource_, node, 'resource')
            self.resource = resource_
            # validate type external-identifier-resource-type
            self.validate_external_identifier_resource_type(self.resource)
        elif nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
# end class external_identifier_type


class external_link_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, external_link=None):
        self.original_tagname_ = None
        if external_link is None:
            self.external_link = []
        else:
            self.external_link = external_link
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, external_link_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if external_link_list_type.subclass:
            return external_link_list_type.subclass(*args_, **kwargs_)
        else:
            return external_link_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_link(self): return self.external_link
    def set_external_link(self, external_link): self.external_link = external_link
    def add_external_link(self, value): self.external_link.append(value)
    def insert_external_link_at(self, index, value): self.external_link.insert(index, value)
    def replace_external_link_at(self, index, value): self.external_link[index] = value
    def hasContent_(self):
        if (
            self.external_link
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='external-link-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='external-link-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='external-link-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='external-link-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='external-link-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_link_ in self.external_link:
            external_link_.export(outfile, level, namespace_, name_='external-link', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external-link':
            obj_ = external_link_type.factory()
            obj_.build(child_)
            self.external_link.append(obj_)
            obj_.original_tagname_ = 'external-link'
# end class external_link_list_type


class external_link_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resource=None, url=None):
        self.original_tagname_ = None
        self.resource = resource
        self.validate_external-link-resource-type(self.resource)
        self.url = url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, external_link_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if external_link_type.subclass:
            return external_link_type.subclass(*args_, **kwargs_)
        else:
            return external_link_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def validate_external_link_resource_type(self, value):
        # Validate type external-link-resource-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RxList', 'PDRhealth', 'Drugs.com']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on external-link-resource-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.resource is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='external-link-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='external-link-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='external-link-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='external-link-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='external-link-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresource>%s</%sresource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.resource), input_name='resource')), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resource':
            resource_ = child_.text
            resource_ = self.gds_validate_string(resource_, node, 'resource')
            self.resource = resource_
            # validate type external-link-resource-type
            self.validate_external_link_resource_type(self.resource)
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
# end class external_link_type


class pathway_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pathway=None):
        self.original_tagname_ = None
        if pathway is None:
            self.pathway = []
        else:
            self.pathway = pathway
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathway_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathway_list_type.subclass:
            return pathway_list_type.subclass(*args_, **kwargs_)
        else:
            return pathway_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathway(self): return self.pathway
    def set_pathway(self, pathway): self.pathway = pathway
    def add_pathway(self, value): self.pathway.append(value)
    def insert_pathway_at(self, index, value): self.pathway.insert(index, value)
    def replace_pathway_at(self, index, value): self.pathway[index] = value
    def hasContent_(self):
        if (
            self.pathway
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pathway-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathway-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pathway-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pathway-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pathway-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathway_ in self.pathway:
            pathway_.export(outfile, level, namespace_, name_='pathway', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pathway':
            obj_ = pathway_type.factory()
            obj_.build(child_)
            self.pathway.append(obj_)
            obj_.original_tagname_ = 'pathway'
# end class pathway_list_type


class pathway_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, smpdb_id=None, name=None, drugs=None, enzymes=None):
        self.original_tagname_ = None
        self.smpdb_id = smpdb_id
        self.name = name
        self.drugs = drugs
        self.enzymes = enzymes
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathway_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathway_type.subclass:
            return pathway_type.subclass(*args_, **kwargs_)
        else:
            return pathway_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_smpdb_id(self): return self.smpdb_id
    def set_smpdb_id(self, smpdb_id): self.smpdb_id = smpdb_id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_drugs(self): return self.drugs
    def set_drugs(self, drugs): self.drugs = drugs
    def get_enzymes(self): return self.enzymes
    def set_enzymes(self, enzymes): self.enzymes = enzymes
    def hasContent_(self):
        if (
            self.smpdb_id is not None or
            self.name is not None or
            self.drugs is not None or
            self.enzymes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pathway-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathway-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pathway-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pathway-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pathway-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.smpdb_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmpdb-id>%s</%ssmpdb-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.smpdb_id), input_name='smpdb-id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.drugs is not None:
            self.drugs.export(outfile, level, namespace_, name_='drugs', pretty_print=pretty_print)
        if self.enzymes is not None:
            self.enzymes.export(outfile, level, namespace_, name_='enzymes', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'smpdb-id':
            smpdb_id_ = child_.text
            smpdb_id_ = self.gds_validate_string(smpdb_id_, node, 'smpdb_id')
            self.smpdb_id = smpdb_id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'drugs':
            obj_ = pathway_drug_list_type.factory()
            obj_.build(child_)
            self.drugs = obj_
            obj_.original_tagname_ = 'drugs'
        elif nodeName_ == 'enzymes':
            obj_ = pathway_enzyme_list_type.factory()
            obj_.build(child_)
            self.enzymes = obj_
            obj_.original_tagname_ = 'enzymes'
# end class pathway_type


class pathway_drug_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drug=None):
        self.original_tagname_ = None
        if drug is None:
            self.drug = []
        else:
            self.drug = drug
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathway_drug_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathway_drug_list_type.subclass:
            return pathway_drug_list_type.subclass(*args_, **kwargs_)
        else:
            return pathway_drug_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drug(self): return self.drug
    def set_drug(self, drug): self.drug = drug
    def add_drug(self, value): self.drug.append(value)
    def insert_drug_at(self, index, value): self.drug.insert(index, value)
    def replace_drug_at(self, index, value): self.drug[index] = value
    def hasContent_(self):
        if (
            self.drug
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pathway-drug-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathway-drug-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pathway-drug-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pathway-drug-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pathway-drug-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for drug_ in self.drug:
            drug_.export(outfile, level, namespace_, name_='drug', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drug':
            obj_ = pathway_drug_type.factory()
            obj_.build(child_)
            self.drug.append(obj_)
            obj_.original_tagname_ = 'drug'
# end class pathway_drug_list_type


class pathway_drug_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drugbank_id=None, name=None):
        self.original_tagname_ = None
        self.drugbank_id = drugbank_id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathway_drug_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathway_drug_type.subclass:
            return pathway_drug_type.subclass(*args_, **kwargs_)
        else:
            return pathway_drug_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drugbank_id(self): return self.drugbank_id
    def set_drugbank_id(self, drugbank_id): self.drugbank_id = drugbank_id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.drugbank_id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pathway-drug-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathway-drug-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pathway-drug-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pathway-drug-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pathway-drug-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drugbank_id is not None:
            self.drugbank_id.export(outfile, level, namespace_, name_='drugbank-id', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drugbank-id':
            obj_ = drugbank_drug_id_type.factory()
            obj_.build(child_)
            self.drugbank_id = obj_
            obj_.original_tagname_ = 'drugbank-id'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class pathway_drug_type


class pathway_enzyme_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniprot_id=None):
        self.original_tagname_ = None
        if uniprot_id is None:
            self.uniprot_id = []
        else:
            self.uniprot_id = uniprot_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathway_enzyme_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathway_enzyme_list_type.subclass:
            return pathway_enzyme_list_type.subclass(*args_, **kwargs_)
        else:
            return pathway_enzyme_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniprot_id(self): return self.uniprot_id
    def set_uniprot_id(self, uniprot_id): self.uniprot_id = uniprot_id
    def add_uniprot_id(self, value): self.uniprot_id.append(value)
    def insert_uniprot_id_at(self, index, value): self.uniprot_id.insert(index, value)
    def replace_uniprot_id_at(self, index, value): self.uniprot_id[index] = value
    def hasContent_(self):
        if (
            self.uniprot_id
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pathway-enzyme-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathway-enzyme-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pathway-enzyme-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pathway-enzyme-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pathway-enzyme-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for uniprot_id_ in self.uniprot_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suniprot-id>%s</%suniprot-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(uniprot_id_), input_name='uniprot-id')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uniprot-id':
            uniprot_id_ = child_.text
            uniprot_id_ = self.gds_validate_string(uniprot_id_, node, 'uniprot_id')
            self.uniprot_id.append(uniprot_id_)
# end class pathway_enzyme_list_type


class reaction_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reaction=None):
        self.original_tagname_ = None
        if reaction is None:
            self.reaction = []
        else:
            self.reaction = reaction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reaction_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reaction_list_type.subclass:
            return reaction_list_type.subclass(*args_, **kwargs_)
        else:
            return reaction_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reaction(self): return self.reaction
    def set_reaction(self, reaction): self.reaction = reaction
    def add_reaction(self, value): self.reaction.append(value)
    def insert_reaction_at(self, index, value): self.reaction.insert(index, value)
    def replace_reaction_at(self, index, value): self.reaction[index] = value
    def hasContent_(self):
        if (
            self.reaction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reaction-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reaction-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reaction-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reaction-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reaction-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reaction_ in self.reaction:
            reaction_.export(outfile, level, namespace_, name_='reaction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reaction':
            obj_ = reaction_type.factory()
            obj_.build(child_)
            self.reaction.append(obj_)
            obj_.original_tagname_ = 'reaction'
# end class reaction_list_type


class reaction_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequence=None, left_element=None, right_element=None, enzymes=None):
        self.original_tagname_ = None
        self.sequence = sequence
        self.left_element = left_element
        self.right_element = right_element
        self.enzymes = enzymes
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reaction_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reaction_type.subclass:
            return reaction_type.subclass(*args_, **kwargs_)
        else:
            return reaction_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_left_element(self): return self.left_element
    def set_left_element(self, left_element): self.left_element = left_element
    def get_right_element(self): return self.right_element
    def set_right_element(self, right_element): self.right_element = right_element
    def get_enzymes(self): return self.enzymes
    def set_enzymes(self, enzymes): self.enzymes = enzymes
    def hasContent_(self):
        if (
            self.sequence is not None or
            self.left_element is not None or
            self.right_element is not None or
            self.enzymes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reaction-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reaction-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reaction-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reaction-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reaction-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence>%s</%ssequence>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.sequence), input_name='sequence')), namespace_, eol_))
        if self.left_element is not None:
            self.left_element.export(outfile, level, namespace_, name_='left-element', pretty_print=pretty_print)
        if self.right_element is not None:
            self.right_element.export(outfile, level, namespace_, name_='right-element', pretty_print=pretty_print)
        if self.enzymes is not None:
            self.enzymes.export(outfile, level, namespace_, name_='enzymes', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequence':
            sequence_ = child_.text
            sequence_ = self.gds_validate_string(sequence_, node, 'sequence')
            self.sequence = sequence_
        elif nodeName_ == 'left-element':
            obj_ = reaction_element_type.factory()
            obj_.build(child_)
            self.left_element = obj_
            obj_.original_tagname_ = 'left-element'
        elif nodeName_ == 'right-element':
            obj_ = reaction_element_type.factory()
            obj_.build(child_)
            self.right_element = obj_
            obj_.original_tagname_ = 'right-element'
        elif nodeName_ == 'enzymes':
            obj_ = reaction_enzyme_list_type.factory()
            obj_.build(child_)
            self.enzymes = obj_
            obj_.original_tagname_ = 'enzymes'
# end class reaction_type


class reaction_element_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drugbank_id=None, name=None):
        self.original_tagname_ = None
        self.drugbank_id = drugbank_id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reaction_element_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reaction_element_type.subclass:
            return reaction_element_type.subclass(*args_, **kwargs_)
        else:
            return reaction_element_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drugbank_id(self): return self.drugbank_id
    def set_drugbank_id(self, drugbank_id): self.drugbank_id = drugbank_id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.drugbank_id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reaction-element-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reaction-element-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reaction-element-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reaction-element-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reaction-element-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drugbank_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdrugbank-id>%s</%sdrugbank-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.drugbank_id), input_name='drugbank-id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drugbank-id':
            drugbank_id_ = child_.text
            drugbank_id_ = self.gds_validate_string(drugbank_id_, node, 'drugbank_id')
            self.drugbank_id = drugbank_id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class reaction_element_type


class reaction_enzyme_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enzyme=None):
        self.original_tagname_ = None
        if enzyme is None:
            self.enzyme = []
        else:
            self.enzyme = enzyme
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reaction_enzyme_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reaction_enzyme_list_type.subclass:
            return reaction_enzyme_list_type.subclass(*args_, **kwargs_)
        else:
            return reaction_enzyme_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enzyme(self): return self.enzyme
    def set_enzyme(self, enzyme): self.enzyme = enzyme
    def add_enzyme(self, value): self.enzyme.append(value)
    def insert_enzyme_at(self, index, value): self.enzyme.insert(index, value)
    def replace_enzyme_at(self, index, value): self.enzyme[index] = value
    def hasContent_(self):
        if (
            self.enzyme
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reaction-enzyme-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reaction-enzyme-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reaction-enzyme-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reaction-enzyme-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reaction-enzyme-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for enzyme_ in self.enzyme:
            enzyme_.export(outfile, level, namespace_, name_='enzyme', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enzyme':
            obj_ = reaction_enzyme_type.factory()
            obj_.build(child_)
            self.enzyme.append(obj_)
            obj_.original_tagname_ = 'enzyme'
# end class reaction_enzyme_list_type


class reaction_enzyme_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, drugbank_id=None, name=None, uniprot_id=None):
        self.original_tagname_ = None
        self.drugbank_id = drugbank_id
        self.name = name
        self.uniprot_id = uniprot_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reaction_enzyme_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reaction_enzyme_type.subclass:
            return reaction_enzyme_type.subclass(*args_, **kwargs_)
        else:
            return reaction_enzyme_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_drugbank_id(self): return self.drugbank_id
    def set_drugbank_id(self, drugbank_id): self.drugbank_id = drugbank_id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_uniprot_id(self): return self.uniprot_id
    def set_uniprot_id(self, uniprot_id): self.uniprot_id = uniprot_id
    def hasContent_(self):
        if (
            self.drugbank_id is not None or
            self.name is not None or
            self.uniprot_id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reaction-enzyme-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reaction-enzyme-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reaction-enzyme-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reaction-enzyme-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reaction-enzyme-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drugbank_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdrugbank-id>%s</%sdrugbank-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.drugbank_id), input_name='drugbank-id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.uniprot_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suniprot-id>%s</%suniprot-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.uniprot_id), input_name='uniprot-id')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'drugbank-id':
            drugbank_id_ = child_.text
            drugbank_id_ = self.gds_validate_string(drugbank_id_, node, 'drugbank_id')
            self.drugbank_id = drugbank_id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'uniprot-id':
            uniprot_id_ = child_.text
            uniprot_id_ = self.gds_validate_string(uniprot_id_, node, 'uniprot_id')
            self.uniprot_id = uniprot_id_
# end class reaction_enzyme_type


class snp_effect_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, effect=None):
        self.original_tagname_ = None
        if effect is None:
            self.effect = []
        else:
            self.effect = effect
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, snp_effect_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if snp_effect_list_type.subclass:
            return snp_effect_list_type.subclass(*args_, **kwargs_)
        else:
            return snp_effect_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_effect(self): return self.effect
    def set_effect(self, effect): self.effect = effect
    def add_effect(self, value): self.effect.append(value)
    def insert_effect_at(self, index, value): self.effect.insert(index, value)
    def replace_effect_at(self, index, value): self.effect[index] = value
    def hasContent_(self):
        if (
            self.effect
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='snp-effect-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='snp-effect-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='snp-effect-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='snp-effect-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='snp-effect-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for effect_ in self.effect:
            effect_.export(outfile, level, namespace_, name_='effect', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'effect':
            obj_ = snp_effect_type.factory()
            obj_.build(child_)
            self.effect.append(obj_)
            obj_.original_tagname_ = 'effect'
# end class snp_effect_list_type


class snp_effect_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protein_name=None, gene_symbol=None, uniprot_id=None, rs_id=None, allele=None, defining_change=None, description=None, pubmed_id=None):
        self.original_tagname_ = None
        self.protein_name = protein_name
        if gene_symbol is None:
            self.gene_symbol = []
        else:
            self.gene_symbol = gene_symbol
        if uniprot_id is None:
            self.uniprot_id = []
        else:
            self.uniprot_id = uniprot_id
        if rs_id is None:
            self.rs_id = []
        else:
            self.rs_id = rs_id
        if allele is None:
            self.allele = []
        else:
            self.allele = allele
        if defining_change is None:
            self.defining_change = []
        else:
            self.defining_change = defining_change
        if description is None:
            self.description = []
        else:
            self.description = description
        if pubmed_id is None:
            self.pubmed_id = []
        else:
            self.pubmed_id = pubmed_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, snp_effect_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if snp_effect_type.subclass:
            return snp_effect_type.subclass(*args_, **kwargs_)
        else:
            return snp_effect_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protein_name(self): return self.protein_name
    def set_protein_name(self, protein_name): self.protein_name = protein_name
    def get_gene_symbol(self): return self.gene_symbol
    def set_gene_symbol(self, gene_symbol): self.gene_symbol = gene_symbol
    def add_gene_symbol(self, value): self.gene_symbol.append(value)
    def insert_gene_symbol_at(self, index, value): self.gene_symbol.insert(index, value)
    def replace_gene_symbol_at(self, index, value): self.gene_symbol[index] = value
    def get_uniprot_id(self): return self.uniprot_id
    def set_uniprot_id(self, uniprot_id): self.uniprot_id = uniprot_id
    def add_uniprot_id(self, value): self.uniprot_id.append(value)
    def insert_uniprot_id_at(self, index, value): self.uniprot_id.insert(index, value)
    def replace_uniprot_id_at(self, index, value): self.uniprot_id[index] = value
    def get_rs_id(self): return self.rs_id
    def set_rs_id(self, rs_id): self.rs_id = rs_id
    def add_rs_id(self, value): self.rs_id.append(value)
    def insert_rs_id_at(self, index, value): self.rs_id.insert(index, value)
    def replace_rs_id_at(self, index, value): self.rs_id[index] = value
    def get_allele(self): return self.allele
    def set_allele(self, allele): self.allele = allele
    def add_allele(self, value): self.allele.append(value)
    def insert_allele_at(self, index, value): self.allele.insert(index, value)
    def replace_allele_at(self, index, value): self.allele[index] = value
    def get_defining_change(self): return self.defining_change
    def set_defining_change(self, defining_change): self.defining_change = defining_change
    def add_defining_change(self, value): self.defining_change.append(value)
    def insert_defining_change_at(self, index, value): self.defining_change.insert(index, value)
    def replace_defining_change_at(self, index, value): self.defining_change[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description_at(self, index, value): self.description.insert(index, value)
    def replace_description_at(self, index, value): self.description[index] = value
    def get_pubmed_id(self): return self.pubmed_id
    def set_pubmed_id(self, pubmed_id): self.pubmed_id = pubmed_id
    def add_pubmed_id(self, value): self.pubmed_id.append(value)
    def insert_pubmed_id_at(self, index, value): self.pubmed_id.insert(index, value)
    def replace_pubmed_id_at(self, index, value): self.pubmed_id[index] = value
    def hasContent_(self):
        if (
            self.protein_name is not None or
            self.gene_symbol or
            self.uniprot_id or
            self.rs_id or
            self.allele or
            self.defining_change or
            self.description or
            self.pubmed_id
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='snp-effect-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='snp-effect-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='snp-effect-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='snp-effect-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='snp-effect-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protein_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotein-name>%s</%sprotein-name>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.protein_name), input_name='protein-name')), namespace_, eol_))
        for gene_symbol_ in self.gene_symbol:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgene-symbol>%s</%sgene-symbol>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(gene_symbol_), input_name='gene-symbol')), namespace_, eol_))
        for uniprot_id_ in self.uniprot_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suniprot-id>%s</%suniprot-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(uniprot_id_), input_name='uniprot-id')), namespace_, eol_))
        for rs_id_ in self.rs_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srs-id>%s</%srs-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(rs_id_), input_name='rs-id')), namespace_, eol_))
        for allele_ in self.allele:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallele>%s</%sallele>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(allele_), input_name='allele')), namespace_, eol_))
        for defining_change_ in self.defining_change:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefining-change>%s</%sdefining-change>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(defining_change_), input_name='defining-change')), namespace_, eol_))
        for description_ in self.description:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(description_), input_name='description')), namespace_, eol_))
        for pubmed_id_ in self.pubmed_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubmed-id>%s</%spubmed-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(pubmed_id_), input_name='pubmed-id')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protein-name':
            protein_name_ = child_.text
            protein_name_ = self.gds_validate_string(protein_name_, node, 'protein_name')
            self.protein_name = protein_name_
        elif nodeName_ == 'gene-symbol':
            gene_symbol_ = child_.text
            gene_symbol_ = self.gds_validate_string(gene_symbol_, node, 'gene_symbol')
            self.gene_symbol.append(gene_symbol_)
        elif nodeName_ == 'uniprot-id':
            uniprot_id_ = child_.text
            uniprot_id_ = self.gds_validate_string(uniprot_id_, node, 'uniprot_id')
            self.uniprot_id.append(uniprot_id_)
        elif nodeName_ == 'rs-id':
            rs_id_ = child_.text
            rs_id_ = self.gds_validate_string(rs_id_, node, 'rs_id')
            self.rs_id.append(rs_id_)
        elif nodeName_ == 'allele':
            allele_ = child_.text
            allele_ = self.gds_validate_string(allele_, node, 'allele')
            self.allele.append(allele_)
        elif nodeName_ == 'defining-change':
            defining_change_ = child_.text
            defining_change_ = self.gds_validate_string(defining_change_, node, 'defining_change')
            self.defining_change.append(defining_change_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'pubmed-id':
            pubmed_id_ = child_.text
            pubmed_id_ = self.gds_validate_string(pubmed_id_, node, 'pubmed_id')
            self.pubmed_id.append(pubmed_id_)
# end class snp_effect_type


class snp_adverse_drug_reaction_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reaction=None):
        self.original_tagname_ = None
        if reaction is None:
            self.reaction = []
        else:
            self.reaction = reaction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, snp_adverse_drug_reaction_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if snp_adverse_drug_reaction_list_type.subclass:
            return snp_adverse_drug_reaction_list_type.subclass(*args_, **kwargs_)
        else:
            return snp_adverse_drug_reaction_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reaction(self): return self.reaction
    def set_reaction(self, reaction): self.reaction = reaction
    def add_reaction(self, value): self.reaction.append(value)
    def insert_reaction_at(self, index, value): self.reaction.insert(index, value)
    def replace_reaction_at(self, index, value): self.reaction[index] = value
    def hasContent_(self):
        if (
            self.reaction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='snp-adverse-drug-reaction-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='snp-adverse-drug-reaction-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='snp-adverse-drug-reaction-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='snp-adverse-drug-reaction-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='snp-adverse-drug-reaction-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reaction_ in self.reaction:
            reaction_.export(outfile, level, namespace_, name_='reaction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reaction':
            obj_ = snp_adverse_drug_reaction_type.factory()
            obj_.build(child_)
            self.reaction.append(obj_)
            obj_.original_tagname_ = 'reaction'
# end class snp_adverse_drug_reaction_list_type


class snp_adverse_drug_reaction_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protein_name=None, gene_symbol=None, uniprot_id=None, rs_id=None, allele=None, adverse_reaction=None, description=None, pubmed_id=None):
        self.original_tagname_ = None
        self.protein_name = protein_name
        if gene_symbol is None:
            self.gene_symbol = []
        else:
            self.gene_symbol = gene_symbol
        if uniprot_id is None:
            self.uniprot_id = []
        else:
            self.uniprot_id = uniprot_id
        if rs_id is None:
            self.rs_id = []
        else:
            self.rs_id = rs_id
        if allele is None:
            self.allele = []
        else:
            self.allele = allele
        if adverse_reaction is None:
            self.adverse_reaction = []
        else:
            self.adverse_reaction = adverse_reaction
        if description is None:
            self.description = []
        else:
            self.description = description
        if pubmed_id is None:
            self.pubmed_id = []
        else:
            self.pubmed_id = pubmed_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, snp_adverse_drug_reaction_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if snp_adverse_drug_reaction_type.subclass:
            return snp_adverse_drug_reaction_type.subclass(*args_, **kwargs_)
        else:
            return snp_adverse_drug_reaction_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protein_name(self): return self.protein_name
    def set_protein_name(self, protein_name): self.protein_name = protein_name
    def get_gene_symbol(self): return self.gene_symbol
    def set_gene_symbol(self, gene_symbol): self.gene_symbol = gene_symbol
    def add_gene_symbol(self, value): self.gene_symbol.append(value)
    def insert_gene_symbol_at(self, index, value): self.gene_symbol.insert(index, value)
    def replace_gene_symbol_at(self, index, value): self.gene_symbol[index] = value
    def get_uniprot_id(self): return self.uniprot_id
    def set_uniprot_id(self, uniprot_id): self.uniprot_id = uniprot_id
    def add_uniprot_id(self, value): self.uniprot_id.append(value)
    def insert_uniprot_id_at(self, index, value): self.uniprot_id.insert(index, value)
    def replace_uniprot_id_at(self, index, value): self.uniprot_id[index] = value
    def get_rs_id(self): return self.rs_id
    def set_rs_id(self, rs_id): self.rs_id = rs_id
    def add_rs_id(self, value): self.rs_id.append(value)
    def insert_rs_id_at(self, index, value): self.rs_id.insert(index, value)
    def replace_rs_id_at(self, index, value): self.rs_id[index] = value
    def get_allele(self): return self.allele
    def set_allele(self, allele): self.allele = allele
    def add_allele(self, value): self.allele.append(value)
    def insert_allele_at(self, index, value): self.allele.insert(index, value)
    def replace_allele_at(self, index, value): self.allele[index] = value
    def get_adverse_reaction(self): return self.adverse_reaction
    def set_adverse_reaction(self, adverse_reaction): self.adverse_reaction = adverse_reaction
    def add_adverse_reaction(self, value): self.adverse_reaction.append(value)
    def insert_adverse_reaction_at(self, index, value): self.adverse_reaction.insert(index, value)
    def replace_adverse_reaction_at(self, index, value): self.adverse_reaction[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description_at(self, index, value): self.description.insert(index, value)
    def replace_description_at(self, index, value): self.description[index] = value
    def get_pubmed_id(self): return self.pubmed_id
    def set_pubmed_id(self, pubmed_id): self.pubmed_id = pubmed_id
    def add_pubmed_id(self, value): self.pubmed_id.append(value)
    def insert_pubmed_id_at(self, index, value): self.pubmed_id.insert(index, value)
    def replace_pubmed_id_at(self, index, value): self.pubmed_id[index] = value
    def hasContent_(self):
        if (
            self.protein_name is not None or
            self.gene_symbol or
            self.uniprot_id or
            self.rs_id or
            self.allele or
            self.adverse_reaction or
            self.description or
            self.pubmed_id
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='snp-adverse-drug-reaction-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='snp-adverse-drug-reaction-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='snp-adverse-drug-reaction-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='snp-adverse-drug-reaction-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='snp-adverse-drug-reaction-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protein_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotein-name>%s</%sprotein-name>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.protein_name), input_name='protein-name')), namespace_, eol_))
        for gene_symbol_ in self.gene_symbol:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgene-symbol>%s</%sgene-symbol>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(gene_symbol_), input_name='gene-symbol')), namespace_, eol_))
        for uniprot_id_ in self.uniprot_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suniprot-id>%s</%suniprot-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(uniprot_id_), input_name='uniprot-id')), namespace_, eol_))
        for rs_id_ in self.rs_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srs-id>%s</%srs-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(rs_id_), input_name='rs-id')), namespace_, eol_))
        for allele_ in self.allele:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallele>%s</%sallele>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(allele_), input_name='allele')), namespace_, eol_))
        for adverse_reaction_ in self.adverse_reaction:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadverse-reaction>%s</%sadverse-reaction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(adverse_reaction_), input_name='adverse-reaction')), namespace_, eol_))
        for description_ in self.description:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(description_), input_name='description')), namespace_, eol_))
        for pubmed_id_ in self.pubmed_id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubmed-id>%s</%spubmed-id>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(pubmed_id_), input_name='pubmed-id')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protein-name':
            protein_name_ = child_.text
            protein_name_ = self.gds_validate_string(protein_name_, node, 'protein_name')
            self.protein_name = protein_name_
        elif nodeName_ == 'gene-symbol':
            gene_symbol_ = child_.text
            gene_symbol_ = self.gds_validate_string(gene_symbol_, node, 'gene_symbol')
            self.gene_symbol.append(gene_symbol_)
        elif nodeName_ == 'uniprot-id':
            uniprot_id_ = child_.text
            uniprot_id_ = self.gds_validate_string(uniprot_id_, node, 'uniprot_id')
            self.uniprot_id.append(uniprot_id_)
        elif nodeName_ == 'rs-id':
            rs_id_ = child_.text
            rs_id_ = self.gds_validate_string(rs_id_, node, 'rs_id')
            self.rs_id.append(rs_id_)
        elif nodeName_ == 'allele':
            allele_ = child_.text
            allele_ = self.gds_validate_string(allele_, node, 'allele')
            self.allele.append(allele_)
        elif nodeName_ == 'adverse-reaction':
            adverse_reaction_ = child_.text
            adverse_reaction_ = self.gds_validate_string(adverse_reaction_, node, 'adverse_reaction')
            self.adverse_reaction.append(adverse_reaction_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'pubmed-id':
            pubmed_id_ = child_.text
            pubmed_id_ = self.gds_validate_string(pubmed_id_, node, 'pubmed_id')
            self.pubmed_id.append(pubmed_id_)
# end class snp_adverse_drug_reaction_type


class polypeptide_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polypeptide=None):
        self.original_tagname_ = None
        if polypeptide is None:
            self.polypeptide = []
        else:
            self.polypeptide = polypeptide
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polypeptide_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polypeptide_list_type.subclass:
            return polypeptide_list_type.subclass(*args_, **kwargs_)
        else:
            return polypeptide_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polypeptide(self): return self.polypeptide
    def set_polypeptide(self, polypeptide): self.polypeptide = polypeptide
    def add_polypeptide(self, value): self.polypeptide.append(value)
    def insert_polypeptide_at(self, index, value): self.polypeptide.insert(index, value)
    def replace_polypeptide_at(self, index, value): self.polypeptide[index] = value
    def hasContent_(self):
        if (
            self.polypeptide
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='polypeptide-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polypeptide-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='polypeptide-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polypeptide-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polypeptide-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for polypeptide_ in self.polypeptide:
            polypeptide_.export(outfile, level, namespace_, name_='polypeptide', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polypeptide':
            obj_ = polypeptide_type.factory()
            obj_.build(child_)
            self.polypeptide.append(obj_)
            obj_.original_tagname_ = 'polypeptide'
# end class polypeptide_list_type


class polypeptide_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, source=None, name=None, general_function=None, specific_function=None, gene_name=None, locus=None, cellular_location=None, transmembrane_regions=None, signal_regions=None, theoretical_pi=None, molecular_weight=None, chromosome_location=None, organism=None, external_identifiers=None, synonyms=None, amino_acid_sequence=None, gene_sequence=None, pfams=None, go_classifiers=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.source = _cast(None, source)
        self.name = name
        self.general_function = general_function
        self.specific_function = specific_function
        self.gene_name = gene_name
        self.locus = locus
        self.cellular_location = cellular_location
        self.transmembrane_regions = transmembrane_regions
        self.signal_regions = signal_regions
        self.theoretical_pi = theoretical_pi
        self.molecular_weight = molecular_weight
        self.chromosome_location = chromosome_location
        self.organism = organism
        self.external_identifiers = external_identifiers
        self.synonyms = synonyms
        self.amino_acid_sequence = amino_acid_sequence
        self.gene_sequence = gene_sequence
        self.pfams = pfams
        self.go_classifiers = go_classifiers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polypeptide_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polypeptide_type.subclass:
            return polypeptide_type.subclass(*args_, **kwargs_)
        else:
            return polypeptide_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_general_function(self): return self.general_function
    def set_general_function(self, general_function): self.general_function = general_function
    def get_specific_function(self): return self.specific_function
    def set_specific_function(self, specific_function): self.specific_function = specific_function
    def get_gene_name(self): return self.gene_name
    def set_gene_name(self, gene_name): self.gene_name = gene_name
    def get_locus(self): return self.locus
    def set_locus(self, locus): self.locus = locus
    def get_cellular_location(self): return self.cellular_location
    def set_cellular_location(self, cellular_location): self.cellular_location = cellular_location
    def get_transmembrane_regions(self): return self.transmembrane_regions
    def set_transmembrane_regions(self, transmembrane_regions): self.transmembrane_regions = transmembrane_regions
    def get_signal_regions(self): return self.signal_regions
    def set_signal_regions(self, signal_regions): self.signal_regions = signal_regions
    def get_theoretical_pi(self): return self.theoretical_pi
    def set_theoretical_pi(self, theoretical_pi): self.theoretical_pi = theoretical_pi
    def get_molecular_weight(self): return self.molecular_weight
    def set_molecular_weight(self, molecular_weight): self.molecular_weight = molecular_weight
    def get_chromosome_location(self): return self.chromosome_location
    def set_chromosome_location(self, chromosome_location): self.chromosome_location = chromosome_location
    def get_organism(self): return self.organism
    def set_organism(self, organism): self.organism = organism
    def get_external_identifiers(self): return self.external_identifiers
    def set_external_identifiers(self, external_identifiers): self.external_identifiers = external_identifiers
    def get_synonyms(self): return self.synonyms
    def set_synonyms(self, synonyms): self.synonyms = synonyms
    def get_amino_acid_sequence(self): return self.amino_acid_sequence
    def set_amino_acid_sequence(self, amino_acid_sequence): self.amino_acid_sequence = amino_acid_sequence
    def get_gene_sequence(self): return self.gene_sequence
    def set_gene_sequence(self, gene_sequence): self.gene_sequence = gene_sequence
    def get_pfams(self): return self.pfams
    def set_pfams(self, pfams): self.pfams = pfams
    def get_go_classifiers(self): return self.go_classifiers
    def set_go_classifiers(self, go_classifiers): self.go_classifiers = go_classifiers
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def hasContent_(self):
        if (
            self.name is not None or
            self.general_function is not None or
            self.specific_function is not None or
            self.gene_name is not None or
            self.locus is not None or
            self.cellular_location is not None or
            self.transmembrane_regions is not None or
            self.signal_regions is not None or
            self.theoretical_pi is not None or
            self.molecular_weight is not None or
            self.chromosome_location is not None or
            self.organism is not None or
            self.external_identifiers is not None or
            self.synonyms is not None or
            self.amino_acid_sequence is not None or
            self.gene_sequence is not None or
            self.pfams is not None or
            self.go_classifiers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='polypeptide-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polypeptide-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='polypeptide-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polypeptide-type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='polypeptide-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.general_function is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeneral-function>%s</%sgeneral-function>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.general_function), input_name='general-function')), namespace_, eol_))
        if self.specific_function is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecific-function>%s</%sspecific-function>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.specific_function), input_name='specific-function')), namespace_, eol_))
        if self.gene_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgene-name>%s</%sgene-name>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.gene_name), input_name='gene-name')), namespace_, eol_))
        if self.locus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocus>%s</%slocus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.locus), input_name='locus')), namespace_, eol_))
        if self.cellular_location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scellular-location>%s</%scellular-location>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cellular_location), input_name='cellular-location')), namespace_, eol_))
        if self.transmembrane_regions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransmembrane-regions>%s</%stransmembrane-regions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.transmembrane_regions), input_name='transmembrane-regions')), namespace_, eol_))
        if self.signal_regions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssignal-regions>%s</%ssignal-regions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.signal_regions), input_name='signal-regions')), namespace_, eol_))
        if self.theoretical_pi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stheoretical-pi>%s</%stheoretical-pi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.theoretical_pi), input_name='theoretical-pi')), namespace_, eol_))
        if self.molecular_weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smolecular-weight>%s</%smolecular-weight>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.molecular_weight), input_name='molecular-weight')), namespace_, eol_))
        if self.chromosome_location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schromosome-location>%s</%schromosome-location>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chromosome_location), input_name='chromosome-location')), namespace_, eol_))
        if self.organism is not None:
            self.organism.export(outfile, level, namespace_, name_='organism', pretty_print=pretty_print)
        if self.external_identifiers is not None:
            self.external_identifiers.export(outfile, level, namespace_, name_='external-identifiers', pretty_print=pretty_print)
        if self.synonyms is not None:
            self.synonyms.export(outfile, level, namespace_, name_='synonyms', pretty_print=pretty_print)
        if self.amino_acid_sequence is not None:
            self.amino_acid_sequence.export(outfile, level, namespace_, name_='amino-acid-sequence', pretty_print=pretty_print)
        if self.gene_sequence is not None:
            self.gene_sequence.export(outfile, level, namespace_, name_='gene-sequence', pretty_print=pretty_print)
        if self.pfams is not None:
            self.pfams.export(outfile, level, namespace_, name_='pfams', pretty_print=pretty_print)
        if self.go_classifiers is not None:
            self.go_classifiers.export(outfile, level, namespace_, name_='go-classifiers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'general-function':
            general_function_ = child_.text
            general_function_ = self.gds_validate_string(general_function_, node, 'general_function')
            self.general_function = general_function_
        elif nodeName_ == 'specific-function':
            specific_function_ = child_.text
            specific_function_ = self.gds_validate_string(specific_function_, node, 'specific_function')
            self.specific_function = specific_function_
        elif nodeName_ == 'gene-name':
            gene_name_ = child_.text
            gene_name_ = self.gds_validate_string(gene_name_, node, 'gene_name')
            self.gene_name = gene_name_
        elif nodeName_ == 'locus':
            locus_ = child_.text
            locus_ = self.gds_validate_string(locus_, node, 'locus')
            self.locus = locus_
        elif nodeName_ == 'cellular-location':
            cellular_location_ = child_.text
            cellular_location_ = self.gds_validate_string(cellular_location_, node, 'cellular_location')
            self.cellular_location = cellular_location_
        elif nodeName_ == 'transmembrane-regions':
            transmembrane_regions_ = child_.text
            transmembrane_regions_ = self.gds_validate_string(transmembrane_regions_, node, 'transmembrane_regions')
            self.transmembrane_regions = transmembrane_regions_
        elif nodeName_ == 'signal-regions':
            signal_regions_ = child_.text
            signal_regions_ = self.gds_validate_string(signal_regions_, node, 'signal_regions')
            self.signal_regions = signal_regions_
        elif nodeName_ == 'theoretical-pi':
            theoretical_pi_ = child_.text
            theoretical_pi_ = self.gds_validate_string(theoretical_pi_, node, 'theoretical_pi')
            self.theoretical_pi = theoretical_pi_
        elif nodeName_ == 'molecular-weight':
            molecular_weight_ = child_.text
            molecular_weight_ = self.gds_validate_string(molecular_weight_, node, 'molecular_weight')
            self.molecular_weight = molecular_weight_
        elif nodeName_ == 'chromosome-location':
            chromosome_location_ = child_.text
            chromosome_location_ = self.gds_validate_string(chromosome_location_, node, 'chromosome_location')
            self.chromosome_location = chromosome_location_
        elif nodeName_ == 'organism':
            obj_ = organismType.factory()
            obj_.build(child_)
            self.organism = obj_
            obj_.original_tagname_ = 'organism'
        elif nodeName_ == 'external-identifiers':
            obj_ = polypeptide_external_identifier_list_type.factory()
            obj_.build(child_)
            self.external_identifiers = obj_
            obj_.original_tagname_ = 'external-identifiers'
        elif nodeName_ == 'synonyms':
            obj_ = polypeptide_synonym_list_type.factory()
            obj_.build(child_)
            self.synonyms = obj_
            obj_.original_tagname_ = 'synonyms'
        elif nodeName_ == 'amino-acid-sequence':
            obj_ = sequence_type.factory()
            obj_.build(child_)
            self.amino_acid_sequence = obj_
            obj_.original_tagname_ = 'amino-acid-sequence'
        elif nodeName_ == 'gene-sequence':
            obj_ = sequence_type.factory()
            obj_.build(child_)
            self.gene_sequence = obj_
            obj_.original_tagname_ = 'gene-sequence'
        elif nodeName_ == 'pfams':
            obj_ = pfam_list_type.factory()
            obj_.build(child_)
            self.pfams = obj_
            obj_.original_tagname_ = 'pfams'
        elif nodeName_ == 'go-classifiers':
            obj_ = go_classifier_list_type.factory()
            obj_.build(child_)
            self.go_classifiers = obj_
            obj_.original_tagname_ = 'go-classifiers'
# end class polypeptide_type


class polypeptide_external_identifier_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, external_identifier=None):
        self.original_tagname_ = None
        if external_identifier is None:
            self.external_identifier = []
        else:
            self.external_identifier = external_identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polypeptide_external_identifier_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polypeptide_external_identifier_list_type.subclass:
            return polypeptide_external_identifier_list_type.subclass(*args_, **kwargs_)
        else:
            return polypeptide_external_identifier_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_identifier(self): return self.external_identifier
    def set_external_identifier(self, external_identifier): self.external_identifier = external_identifier
    def add_external_identifier(self, value): self.external_identifier.append(value)
    def insert_external_identifier_at(self, index, value): self.external_identifier.insert(index, value)
    def replace_external_identifier_at(self, index, value): self.external_identifier[index] = value
    def hasContent_(self):
        if (
            self.external_identifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='polypeptide-external-identifier-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polypeptide-external-identifier-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='polypeptide-external-identifier-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polypeptide-external-identifier-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polypeptide-external-identifier-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_identifier_ in self.external_identifier:
            external_identifier_.export(outfile, level, namespace_, name_='external-identifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external-identifier':
            obj_ = polypeptide_external_identifier_type.factory()
            obj_.build(child_)
            self.external_identifier.append(obj_)
            obj_.original_tagname_ = 'external-identifier'
# end class polypeptide_external_identifier_list_type


class polypeptide_external_identifier_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resource=None, identifier=None):
        self.original_tagname_ = None
        self.resource = resource
        self.validate_polypeptide-external-identifier-resource-type(self.resource)
        self.identifier = identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polypeptide_external_identifier_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polypeptide_external_identifier_type.subclass:
            return polypeptide_external_identifier_type.subclass(*args_, **kwargs_)
        else:
            return polypeptide_external_identifier_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def validate_polypeptide_external_identifier_resource_type(self, value):
        # Validate type polypeptide-external-identifier-resource-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UniProtKB', 'UniProt Accession', 'HUGO Gene Nomenclature Committee (HGNC)', 'Human Protein Reference Database (HPRD)', 'GenAtlas', 'GeneCards', 'GenBank Gene Database', 'GenBank Protein Database', 'ChEMBL', 'IUPHAR', 'Guide to Pharmacology']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on polypeptide-external-identifier-resource-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.resource is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='polypeptide-external-identifier-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polypeptide-external-identifier-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='polypeptide-external-identifier-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polypeptide-external-identifier-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polypeptide-external-identifier-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresource>%s</%sresource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.resource), input_name='resource')), namespace_, eol_))
        if self.identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.identifier), input_name='identifier')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resource':
            resource_ = child_.text
            resource_ = self.gds_validate_string(resource_, node, 'resource')
            self.resource = resource_
            # validate type polypeptide-external-identifier-resource-type
            self.validate_polypeptide_external_identifier_resource_type(self.resource)
        elif nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
# end class polypeptide_external_identifier_type


class polypeptide_synonym_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, synonym=None):
        self.original_tagname_ = None
        if synonym is None:
            self.synonym = []
        else:
            self.synonym = synonym
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polypeptide_synonym_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polypeptide_synonym_list_type.subclass:
            return polypeptide_synonym_list_type.subclass(*args_, **kwargs_)
        else:
            return polypeptide_synonym_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_synonym(self): return self.synonym
    def set_synonym(self, synonym): self.synonym = synonym
    def add_synonym(self, value): self.synonym.append(value)
    def insert_synonym_at(self, index, value): self.synonym.insert(index, value)
    def replace_synonym_at(self, index, value): self.synonym[index] = value
    def hasContent_(self):
        if (
            self.synonym
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='polypeptide-synonym-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polypeptide-synonym-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='polypeptide-synonym-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polypeptide-synonym-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polypeptide-synonym-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for synonym_ in self.synonym:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssynonym>%s</%ssynonym>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(synonym_), input_name='synonym')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'synonym':
            synonym_ = child_.text
            synonym_ = self.gds_validate_string(synonym_, node, 'synonym')
            self.synonym.append(synonym_)
# end class polypeptide_synonym_list_type


class sequence_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, format=None, valueOf_=None):
        self.original_tagname_ = None
        self.format = _cast(None, format)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sequence_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sequence_type.subclass:
            return sequence_type.subclass(*args_, **kwargs_)
        else:
            return sequence_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequence-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequence-type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequence-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequence-type'):
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.format), input_name='format')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sequence-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sequence_type


class pfam_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pfam=None):
        self.original_tagname_ = None
        if pfam is None:
            self.pfam = []
        else:
            self.pfam = pfam
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pfam_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pfam_list_type.subclass:
            return pfam_list_type.subclass(*args_, **kwargs_)
        else:
            return pfam_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pfam(self): return self.pfam
    def set_pfam(self, pfam): self.pfam = pfam
    def add_pfam(self, value): self.pfam.append(value)
    def insert_pfam_at(self, index, value): self.pfam.insert(index, value)
    def replace_pfam_at(self, index, value): self.pfam[index] = value
    def hasContent_(self):
        if (
            self.pfam
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pfam-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pfam-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pfam-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pfam-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pfam-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pfam_ in self.pfam:
            pfam_.export(outfile, level, namespace_, name_='pfam', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pfam':
            obj_ = pfam_type.factory()
            obj_.build(child_)
            self.pfam.append(obj_)
            obj_.original_tagname_ = 'pfam'
# end class pfam_list_type


class pfam_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None):
        self.original_tagname_ = None
        self.identifier = identifier
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pfam_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pfam_type.subclass:
            return pfam_type.subclass(*args_, **kwargs_)
        else:
            return pfam_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.identifier is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pfam-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pfam-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pfam-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pfam-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pfam-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.identifier), input_name='identifier')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class pfam_type


class go_classifier_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, go_classifier=None):
        self.original_tagname_ = None
        if go_classifier is None:
            self.go_classifier = []
        else:
            self.go_classifier = go_classifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, go_classifier_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if go_classifier_list_type.subclass:
            return go_classifier_list_type.subclass(*args_, **kwargs_)
        else:
            return go_classifier_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_go_classifier(self): return self.go_classifier
    def set_go_classifier(self, go_classifier): self.go_classifier = go_classifier
    def add_go_classifier(self, value): self.go_classifier.append(value)
    def insert_go_classifier_at(self, index, value): self.go_classifier.insert(index, value)
    def replace_go_classifier_at(self, index, value): self.go_classifier[index] = value
    def hasContent_(self):
        if (
            self.go_classifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='go-classifier-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='go-classifier-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='go-classifier-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='go-classifier-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='go-classifier-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for go_classifier_ in self.go_classifier:
            go_classifier_.export(outfile, level, namespace_, name_='go-classifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'go-classifier':
            obj_ = go_classifier_type.factory()
            obj_.build(child_)
            self.go_classifier.append(obj_)
            obj_.original_tagname_ = 'go-classifier'
# end class go_classifier_list_type


class go_classifier_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, category=None, description=None):
        self.original_tagname_ = None
        self.category = category
        self.description = description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, go_classifier_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if go_classifier_type.subclass:
            return go_classifier_type.subclass(*args_, **kwargs_)
        else:
            return go_classifier_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.category is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='go-classifier-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='go-classifier-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='go-classifier-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='go-classifier-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='go-classifier-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scategory>%s</%scategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.category), input_name='category')), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            category_ = child_.text
            category_ = self.gds_validate_string(category_, node, 'category')
            self.category = category_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
# end class go_classifier_type


class action_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None):
        self.original_tagname_ = None
        if action is None:
            self.action = []
        else:
            self.action = action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, action_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if action_list_type.subclass:
            return action_list_type.subclass(*args_, **kwargs_)
        else:
            return action_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def add_action(self, value): self.action.append(value)
    def insert_action_at(self, index, value): self.action.insert(index, value)
    def replace_action_at(self, index, value): self.action[index] = value
    def hasContent_(self):
        if (
            self.action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='action-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='action-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='action-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='action-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='action-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for action_ in self.action:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(action_), input_name='action')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action.append(action_)
# end class action_list_type


class target_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, target=None):
        self.original_tagname_ = None
        if target is None:
            self.target = []
        else:
            self.target = target
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, target_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if target_list_type.subclass:
            return target_list_type.subclass(*args_, **kwargs_)
        else:
            return target_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def add_target(self, value): self.target.append(value)
    def insert_target_at(self, index, value): self.target.insert(index, value)
    def replace_target_at(self, index, value): self.target[index] = value
    def hasContent_(self):
        if (
            self.target
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='target-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='target-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='target-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='target-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='target-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for target_ in self.target:
            target_.export(outfile, level, namespace_, name_='target', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'target':
            obj_ = target_type.factory()
            obj_.build(child_)
            self.target.append(obj_)
            obj_.original_tagname_ = 'target'
# end class target_list_type


class target_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, position=None, id=None, name=None, organism=None, actions=None, references=None, known_action=None, polypeptide=None):
        self.original_tagname_ = None
        self.position = _cast(int, position)
        self.id = id
        self.name = name
        self.organism = organism
        self.actions = actions
        self.references = references
        self.known_action = known_action
        self.validate_known-action-type(self.known_action)
        if polypeptide is None:
            self.polypeptide = []
        else:
            self.polypeptide = polypeptide
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, target_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if target_type.subclass:
            return target_type.subclass(*args_, **kwargs_)
        else:
            return target_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_organism(self): return self.organism
    def set_organism(self, organism): self.organism = organism
    def get_actions(self): return self.actions
    def set_actions(self, actions): self.actions = actions
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_known_action(self): return self.known_action
    def set_known_action(self, known_action): self.known_action = known_action
    def get_polypeptide(self): return self.polypeptide
    def set_polypeptide(self, polypeptide): self.polypeptide = polypeptide
    def add_polypeptide(self, value): self.polypeptide.append(value)
    def insert_polypeptide_at(self, index, value): self.polypeptide.insert(index, value)
    def replace_polypeptide_at(self, index, value): self.polypeptide[index] = value
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def validate_known_action_type(self, value):
        # Validate type known-action-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on known-action-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.organism is not None or
            self.actions is not None or
            self.references is not None or
            self.known_action is not None or
            self.polypeptide
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='target-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='target-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='target-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='target-type'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='', name_='target-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.id), input_name='id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.organism is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganism>%s</%sorganism>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.organism), input_name='organism')), namespace_, eol_))
        if self.actions is not None:
            self.actions.export(outfile, level, namespace_, name_='actions', pretty_print=pretty_print)
        if self.references is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferences>%s</%sreferences>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.references), input_name='references')), namespace_, eol_))
        if self.known_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sknown-action>%s</%sknown-action>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.known_action), input_name='known-action')), namespace_, eol_))
        for polypeptide_ in self.polypeptide:
            polypeptide_.export(outfile, level, namespace_, name_='polypeptide', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            try:
                self.position = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'organism':
            organism_ = child_.text
            organism_ = self.gds_validate_string(organism_, node, 'organism')
            self.organism = organism_
        elif nodeName_ == 'actions':
            obj_ = action_list_type.factory()
            obj_.build(child_)
            self.actions = obj_
            obj_.original_tagname_ = 'actions'
        elif nodeName_ == 'references':
            references_ = child_.text
            references_ = self.gds_validate_string(references_, node, 'references')
            self.references = references_
        elif nodeName_ == 'known-action':
            known_action_ = child_.text
            known_action_ = self.gds_validate_string(known_action_, node, 'known_action')
            self.known_action = known_action_
            # validate type known-action-type
            self.validate_known_action_type(self.known_action)
        elif nodeName_ == 'polypeptide':
            obj_ = polypeptide_type.factory()
            obj_.build(child_)
            self.polypeptide.append(obj_)
            obj_.original_tagname_ = 'polypeptide'
# end class target_type


class enzyme_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enzyme=None):
        self.original_tagname_ = None
        if enzyme is None:
            self.enzyme = []
        else:
            self.enzyme = enzyme
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enzyme_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enzyme_list_type.subclass:
            return enzyme_list_type.subclass(*args_, **kwargs_)
        else:
            return enzyme_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enzyme(self): return self.enzyme
    def set_enzyme(self, enzyme): self.enzyme = enzyme
    def add_enzyme(self, value): self.enzyme.append(value)
    def insert_enzyme_at(self, index, value): self.enzyme.insert(index, value)
    def replace_enzyme_at(self, index, value): self.enzyme[index] = value
    def hasContent_(self):
        if (
            self.enzyme
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='enzyme-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='enzyme-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='enzyme-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='enzyme-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='enzyme-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for enzyme_ in self.enzyme:
            enzyme_.export(outfile, level, namespace_, name_='enzyme', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enzyme':
            obj_ = enzyme_type.factory()
            obj_.build(child_)
            self.enzyme.append(obj_)
            obj_.original_tagname_ = 'enzyme'
# end class enzyme_list_type


class enzyme_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, position=None, id=None, name=None, organism=None, actions=None, references=None, known_action=None, polypeptide=None, inhibition_strength=None, induction_strength=None):
        self.original_tagname_ = None
        self.position = _cast(int, position)
        self.id = id
        self.name = name
        self.organism = organism
        self.actions = actions
        self.references = references
        self.known_action = known_action
        self.validate_known-action-type(self.known_action)
        if polypeptide is None:
            self.polypeptide = []
        else:
            self.polypeptide = polypeptide
        self.inhibition_strength = inhibition_strength
        self.induction_strength = induction_strength
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enzyme_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enzyme_type.subclass:
            return enzyme_type.subclass(*args_, **kwargs_)
        else:
            return enzyme_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_organism(self): return self.organism
    def set_organism(self, organism): self.organism = organism
    def get_actions(self): return self.actions
    def set_actions(self, actions): self.actions = actions
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_known_action(self): return self.known_action
    def set_known_action(self, known_action): self.known_action = known_action
    def get_polypeptide(self): return self.polypeptide
    def set_polypeptide(self, polypeptide): self.polypeptide = polypeptide
    def add_polypeptide(self, value): self.polypeptide.append(value)
    def insert_polypeptide_at(self, index, value): self.polypeptide.insert(index, value)
    def replace_polypeptide_at(self, index, value): self.polypeptide[index] = value
    def get_inhibition_strength(self): return self.inhibition_strength
    def set_inhibition_strength(self, inhibition_strength): self.inhibition_strength = inhibition_strength
    def get_induction_strength(self): return self.induction_strength
    def set_induction_strength(self, induction_strength): self.induction_strength = induction_strength
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def validate_known_action_type(self, value):
        # Validate type known-action-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on known-action-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.organism is not None or
            self.actions is not None or
            self.references is not None or
            self.known_action is not None or
            self.polypeptide or
            self.inhibition_strength is not None or
            self.induction_strength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='enzyme-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='enzyme-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='enzyme-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='enzyme-type'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='', name_='enzyme-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.id), input_name='id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.organism is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganism>%s</%sorganism>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.organism), input_name='organism')), namespace_, eol_))
        if self.actions is not None:
            self.actions.export(outfile, level, namespace_, name_='actions', pretty_print=pretty_print)
        if self.references is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferences>%s</%sreferences>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.references), input_name='references')), namespace_, eol_))
        if self.known_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sknown-action>%s</%sknown-action>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.known_action), input_name='known-action')), namespace_, eol_))
        for polypeptide_ in self.polypeptide:
            polypeptide_.export(outfile, level, namespace_, name_='polypeptide', pretty_print=pretty_print)
        if self.inhibition_strength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinhibition-strength>%s</%sinhibition-strength>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.inhibition_strength), input_name='inhibition-strength')), namespace_, eol_))
        if self.induction_strength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinduction-strength>%s</%sinduction-strength>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.induction_strength), input_name='induction-strength')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            try:
                self.position = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'organism':
            organism_ = child_.text
            organism_ = self.gds_validate_string(organism_, node, 'organism')
            self.organism = organism_
        elif nodeName_ == 'actions':
            obj_ = action_list_type.factory()
            obj_.build(child_)
            self.actions = obj_
            obj_.original_tagname_ = 'actions'
        elif nodeName_ == 'references':
            references_ = child_.text
            references_ = self.gds_validate_string(references_, node, 'references')
            self.references = references_
        elif nodeName_ == 'known-action':
            known_action_ = child_.text
            known_action_ = self.gds_validate_string(known_action_, node, 'known_action')
            self.known_action = known_action_
            # validate type known-action-type
            self.validate_known_action_type(self.known_action)
        elif nodeName_ == 'polypeptide':
            obj_ = polypeptide_type.factory()
            obj_.build(child_)
            self.polypeptide.append(obj_)
            obj_.original_tagname_ = 'polypeptide'
        elif nodeName_ == 'inhibition-strength':
            inhibition_strength_ = child_.text
            inhibition_strength_ = self.gds_validate_string(inhibition_strength_, node, 'inhibition_strength')
            self.inhibition_strength = inhibition_strength_
        elif nodeName_ == 'induction-strength':
            induction_strength_ = child_.text
            induction_strength_ = self.gds_validate_string(induction_strength_, node, 'induction_strength')
            self.induction_strength = induction_strength_
# end class enzyme_type


class carrier_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, carrier=None):
        self.original_tagname_ = None
        if carrier is None:
            self.carrier = []
        else:
            self.carrier = carrier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, carrier_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if carrier_list_type.subclass:
            return carrier_list_type.subclass(*args_, **kwargs_)
        else:
            return carrier_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_carrier(self): return self.carrier
    def set_carrier(self, carrier): self.carrier = carrier
    def add_carrier(self, value): self.carrier.append(value)
    def insert_carrier_at(self, index, value): self.carrier.insert(index, value)
    def replace_carrier_at(self, index, value): self.carrier[index] = value
    def hasContent_(self):
        if (
            self.carrier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='carrier-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='carrier-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='carrier-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='carrier-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='carrier-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for carrier_ in self.carrier:
            carrier_.export(outfile, level, namespace_, name_='carrier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'carrier':
            obj_ = carrier_type.factory()
            obj_.build(child_)
            self.carrier.append(obj_)
            obj_.original_tagname_ = 'carrier'
# end class carrier_list_type


class carrier_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, position=None, id=None, name=None, organism=None, actions=None, references=None, known_action=None, polypeptide=None):
        self.original_tagname_ = None
        self.position = _cast(int, position)
        self.id = id
        self.name = name
        self.organism = organism
        self.actions = actions
        self.references = references
        self.known_action = known_action
        self.validate_known-action-type(self.known_action)
        if polypeptide is None:
            self.polypeptide = []
        else:
            self.polypeptide = polypeptide
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, carrier_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if carrier_type.subclass:
            return carrier_type.subclass(*args_, **kwargs_)
        else:
            return carrier_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_organism(self): return self.organism
    def set_organism(self, organism): self.organism = organism
    def get_actions(self): return self.actions
    def set_actions(self, actions): self.actions = actions
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_known_action(self): return self.known_action
    def set_known_action(self, known_action): self.known_action = known_action
    def get_polypeptide(self): return self.polypeptide
    def set_polypeptide(self, polypeptide): self.polypeptide = polypeptide
    def add_polypeptide(self, value): self.polypeptide.append(value)
    def insert_polypeptide_at(self, index, value): self.polypeptide.insert(index, value)
    def replace_polypeptide_at(self, index, value): self.polypeptide[index] = value
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def validate_known_action_type(self, value):
        # Validate type known-action-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on known-action-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.organism is not None or
            self.actions is not None or
            self.references is not None or
            self.known_action is not None or
            self.polypeptide
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='carrier-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='carrier-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='carrier-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='carrier-type'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='', name_='carrier-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.id), input_name='id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.organism is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganism>%s</%sorganism>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.organism), input_name='organism')), namespace_, eol_))
        if self.actions is not None:
            self.actions.export(outfile, level, namespace_, name_='actions', pretty_print=pretty_print)
        if self.references is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferences>%s</%sreferences>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.references), input_name='references')), namespace_, eol_))
        if self.known_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sknown-action>%s</%sknown-action>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.known_action), input_name='known-action')), namespace_, eol_))
        for polypeptide_ in self.polypeptide:
            polypeptide_.export(outfile, level, namespace_, name_='polypeptide', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            try:
                self.position = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'organism':
            organism_ = child_.text
            organism_ = self.gds_validate_string(organism_, node, 'organism')
            self.organism = organism_
        elif nodeName_ == 'actions':
            obj_ = action_list_type.factory()
            obj_.build(child_)
            self.actions = obj_
            obj_.original_tagname_ = 'actions'
        elif nodeName_ == 'references':
            references_ = child_.text
            references_ = self.gds_validate_string(references_, node, 'references')
            self.references = references_
        elif nodeName_ == 'known-action':
            known_action_ = child_.text
            known_action_ = self.gds_validate_string(known_action_, node, 'known_action')
            self.known_action = known_action_
            # validate type known-action-type
            self.validate_known_action_type(self.known_action)
        elif nodeName_ == 'polypeptide':
            obj_ = polypeptide_type.factory()
            obj_.build(child_)
            self.polypeptide.append(obj_)
            obj_.original_tagname_ = 'polypeptide'
# end class carrier_type


class transporter_list_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transporter=None):
        self.original_tagname_ = None
        if transporter is None:
            self.transporter = []
        else:
            self.transporter = transporter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transporter_list_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transporter_list_type.subclass:
            return transporter_list_type.subclass(*args_, **kwargs_)
        else:
            return transporter_list_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transporter(self): return self.transporter
    def set_transporter(self, transporter): self.transporter = transporter
    def add_transporter(self, value): self.transporter.append(value)
    def insert_transporter_at(self, index, value): self.transporter.insert(index, value)
    def replace_transporter_at(self, index, value): self.transporter[index] = value
    def hasContent_(self):
        if (
            self.transporter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transporter-list-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transporter-list-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transporter-list-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transporter-list-type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='transporter-list-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for transporter_ in self.transporter:
            transporter_.export(outfile, level, namespace_, name_='transporter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transporter':
            obj_ = transporter_type.factory()
            obj_.build(child_)
            self.transporter.append(obj_)
            obj_.original_tagname_ = 'transporter'
# end class transporter_list_type


class transporter_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, position=None, id=None, name=None, organism=None, actions=None, references=None, known_action=None, polypeptide=None):
        self.original_tagname_ = None
        self.position = _cast(int, position)
        self.id = id
        self.name = name
        self.organism = organism
        self.actions = actions
        self.references = references
        self.known_action = known_action
        self.validate_known-action-type(self.known_action)
        if polypeptide is None:
            self.polypeptide = []
        else:
            self.polypeptide = polypeptide
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transporter_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transporter_type.subclass:
            return transporter_type.subclass(*args_, **kwargs_)
        else:
            return transporter_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_organism(self): return self.organism
    def set_organism(self, organism): self.organism = organism
    def get_actions(self): return self.actions
    def set_actions(self, actions): self.actions = actions
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_known_action(self): return self.known_action
    def set_known_action(self, known_action): self.known_action = known_action
    def get_polypeptide(self): return self.polypeptide
    def set_polypeptide(self, polypeptide): self.polypeptide = polypeptide
    def add_polypeptide(self, value): self.polypeptide.append(value)
    def insert_polypeptide_at(self, index, value): self.polypeptide.insert(index, value)
    def replace_polypeptide_at(self, index, value): self.polypeptide[index] = value
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def validate_known_action_type(self, value):
        # Validate type known-action-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on known-action-type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.organism is not None or
            self.actions is not None or
            self.references is not None or
            self.known_action is not None or
            self.polypeptide
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transporter-type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transporter-type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transporter-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transporter-type'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='', name_='transporter-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.id), input_name='id')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.organism is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganism>%s</%sorganism>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.organism), input_name='organism')), namespace_, eol_))
        if self.actions is not None:
            self.actions.export(outfile, level, namespace_, name_='actions', pretty_print=pretty_print)
        if self.references is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferences>%s</%sreferences>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.references), input_name='references')), namespace_, eol_))
        if self.known_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sknown-action>%s</%sknown-action>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.known_action), input_name='known-action')), namespace_, eol_))
        for polypeptide_ in self.polypeptide:
            polypeptide_.export(outfile, level, namespace_, name_='polypeptide', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            try:
                self.position = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'organism':
            organism_ = child_.text
            organism_ = self.gds_validate_string(organism_, node, 'organism')
            self.organism = organism_
        elif nodeName_ == 'actions':
            obj_ = action_list_type.factory()
            obj_.build(child_)
            self.actions = obj_
            obj_.original_tagname_ = 'actions'
        elif nodeName_ == 'references':
            references_ = child_.text
            references_ = self.gds_validate_string(references_, node, 'references')
            self.references = references_
        elif nodeName_ == 'known-action':
            known_action_ = child_.text
            known_action_ = self.gds_validate_string(known_action_, node, 'known_action')
            self.known_action = known_action_
            # validate type known-action-type
            self.validate_known_action_type(self.known_action)
        elif nodeName_ == 'polypeptide':
            obj_ = polypeptide_type.factory()
            obj_.build(child_)
            self.polypeptide.append(obj_)
            obj_.original_tagname_ = 'polypeptide'
# end class transporter_type


class costType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, currency=None, valueOf_=None):
        self.original_tagname_ = None
        self.currency = _cast(None, currency)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, costType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if costType.subclass:
            return costType.subclass(*args_, **kwargs_)
        else:
            return costType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='costType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='costType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='costType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='costType'):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='costType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class costType


class sequenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, format=None, valueOf_=None):
        self.original_tagname_ = None
        self.format = _cast(None, format)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sequenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sequenceType.subclass:
            return sequenceType.subclass(*args_, **kwargs_)
        else:
            return sequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequenceType'):
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.format), input_name='format')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sequenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sequenceType


class organismType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ncbi_taxonomy_id=None, valueOf_=None):
        self.original_tagname_ = None
        self.ncbi_taxonomy_id = _cast(None, ncbi_taxonomy_id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, organismType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if organismType.subclass:
            return organismType.subclass(*args_, **kwargs_)
        else:
            return organismType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ncbi_taxonomy_id(self): return self.ncbi_taxonomy_id
    def set_ncbi_taxonomy_id(self, ncbi_taxonomy_id): self.ncbi_taxonomy_id = ncbi_taxonomy_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='organismType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='organismType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='organismType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='organismType'):
        if self.ncbi_taxonomy_id is not None and 'ncbi_taxonomy_id' not in already_processed:
            already_processed.add('ncbi_taxonomy_id')
            outfile.write(' ncbi-taxonomy-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ncbi_taxonomy_id), input_name='ncbi-taxonomy-id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='organismType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ncbi-taxonomy-id', node)
        if value is not None and 'ncbi-taxonomy-id' not in already_processed:
            already_processed.add('ncbi-taxonomy-id')
            self.ncbi_taxonomy_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class organismType


GDSClassesMapping = {
    'actions': action_list_type,
    'affected-organisms': affected_organism_list_type,
    'ahfs-codes': ahfs_code_list_type,
    'amino-acid-sequence': sequence_type,
    'atc-code': atc_code_type,
    'atc-codes': atc_code_list_type,
    'calculated-properties': calculated_property_list_type,
    'carrier': carrier_type,
    'carriers': carrier_list_type,
    'categories': category_list_type,
    'category': category_type,
    'classification': classification_type,
    'cost': costType,
    'dosage': dosage_type,
    'dosages': dosage_list_type,
    'drug': pathway_drug_type,
    'drug-interaction': drug_interaction_type,
    'drug-interactions': drug_interaction_list_type,
    'drugbank': drugbank_type,
    'drugbank-id': drugbank_drug_id_type,
    'drugs': pathway_drug_list_type,
    'effect': snp_effect_type,
    'enzyme': enzyme_type,
    'enzymes': reaction_enzyme_list_type,
    'experimental-properties': experimental_property_list_type,
    'external-identifier': polypeptide_external_identifier_type,
    'external-identifiers': polypeptide_external_identifier_list_type,
    'external-link': external_link_type,
    'external-links': external_link_list_type,
    'food-interactions': food_interaction_list_type,
    'gene-sequence': sequence_type,
    'go-classifier': go_classifier_type,
    'go-classifiers': go_classifier_list_type,
    'groups': group_list_type,
    'international-brand': international_brand_type,
    'international-brands': international_brand_list_type,
    'left-element': reaction_element_type,
    'level': atc_code_level_type,
    'manufacturer': manufacturer_type,
    'manufacturers': manufacturer_list_type,
    'mixture': mixture_type,
    'mixtures': mixture_list_type,
    'organism': organismType,
    'packager': packager_type,
    'packagers': packager_list_type,
    'patent': patent_type,
    'patents': patent_list_type,
    'pathway': pathway_type,
    'pathways': pathway_list_type,
    'pfam': pfam_type,
    'pfams': pfam_list_type,
    'polypeptide': polypeptide_type,
    'price': price_type,
    'prices': price_list_type,
    'product': product_type,
    'products': product_list_type,
    'property': experimental_property_type,
    'reaction': snp_adverse_drug_reaction_type,
    'reactions': reaction_list_type,
    'right-element': reaction_element_type,
    'salt': salt_type,
    'salts': salt_list_type,
    'sequence': sequenceType,
    'sequences': sequence_list_type,
    'snp-adverse-drug-reactions': snp_adverse_drug_reaction_list_type,
    'snp-effects': snp_effect_list_type,
    'synonym': synonym_type,
    'synonyms': polypeptide_synonym_list_type,
    'target': target_type,
    'targets': target_list_type,
    'transporter': transporter_type,
    'transporters': transporter_list_type,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'drugbank_type'
        rootClass = drugbank_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'drugbank_type'
        rootClass = drugbank_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'drugbank_type'
        rootClass = drugbank_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'drugbank_type'
        rootClass = drugbank_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from drugbank import *\n\n')
        sys.stdout.write('import drugbank as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "action_list_type",
    "affected_organism_list_type",
    "ahfs_code_list_type",
    "atc_code_level_type",
    "atc_code_list_type",
    "atc_code_type",
    "calculated_property_list_type",
    "calculated_property_type",
    "carrier_list_type",
    "carrier_type",
    "category_list_type",
    "category_type",
    "classification_type",
    "costType",
    "dosage_list_type",
    "dosage_type",
    "drug_interaction_list_type",
    "drug_interaction_type",
    "drug_type",
    "drugbank_drug_id_type",
    "drugbank_metabolite_id_type",
    "drugbank_salt_id_type",
    "drugbank_type",
    "enzyme_list_type",
    "enzyme_type",
    "experimental_property_list_type",
    "experimental_property_type",
    "external_identifier_list_type",
    "external_identifier_type",
    "external_link_list_type",
    "external_link_type",
    "food_interaction_list_type",
    "go_classifier_list_type",
    "go_classifier_type",
    "group_list_type",
    "international_brand_list_type",
    "international_brand_type",
    "manufacturer_list_type",
    "manufacturer_type",
    "mixture_list_type",
    "mixture_type",
    "organismType",
    "packager_list_type",
    "packager_type",
    "patent_list_type",
    "patent_type",
    "pathway_drug_list_type",
    "pathway_drug_type",
    "pathway_enzyme_list_type",
    "pathway_list_type",
    "pathway_type",
    "pfam_list_type",
    "pfam_type",
    "polypeptide_external_identifier_list_type",
    "polypeptide_external_identifier_type",
    "polypeptide_list_type",
    "polypeptide_synonym_list_type",
    "polypeptide_type",
    "price_list_type",
    "price_type",
    "product_list_type",
    "product_type",
    "reaction_element_type",
    "reaction_enzyme_list_type",
    "reaction_enzyme_type",
    "reaction_list_type",
    "reaction_type",
    "salt_list_type",
    "salt_type",
    "sequenceType",
    "sequence_list_type",
    "sequence_type",
    "snp_adverse_drug_reaction_list_type",
    "snp_adverse_drug_reaction_type",
    "snp_effect_list_type",
    "snp_effect_type",
    "synonym_list_type",
    "synonym_type",
    "target_list_type",
    "target_type",
    "transporter_list_type",
    "transporter_type"
]
